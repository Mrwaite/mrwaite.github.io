<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mrwaite`s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://code.mrwaite.cn/"/>
  <updated>2017-01-14T02:42:51.373Z</updated>
  <id>http://code.mrwaite.cn/</id>
  
  <author>
    <name>Mrwaite</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>迟来的Vuejs组件化实践总结</title>
    <link href="http://code.mrwaite.cn/2017/01/13/%E8%BF%9F%E6%9D%A5%E7%9A%84Vuejs%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://code.mrwaite.cn/2017/01/13/迟来的Vuejs组件化实践总结/</id>
    <published>2017-01-13T14:00:35.000Z</published>
    <updated>2017-01-14T02:42:51.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迟来的Vuejs组件化实践总结"><a href="#迟来的Vuejs组件化实践总结" class="headerlink" title="迟来的Vuejs组件化实践总结"></a>迟来的Vuejs组件化实践总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开始接触Vuejs是在2016年国庆的时候,正好赶上1.0过渡到2.0,也开始了正式的组件化编程.下面我做的简单的多人博客平台是期末考时候就差不多完成的,然后因为时间问题拖到现在才写下这篇总结,效果已经大打折扣…</p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p><strong>前端</strong> : Vuejs + Vuex + Vue-resource + Vue-router + Sass + webpack + ES6</p>
<p><strong>后端</strong> : Nodejs + Express + MongoDB</p>
<a id="more"></a>
<h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p><strong>目录结构</strong></p>
<p>前端：<br><img src="./1484311184876.png" alt="Alt text"></p>
<p>api: 负责前端与后端的HTTP请求部分（使用Vue-resource）<br>components: 公共组件<br>filter: Vuejs 2.0 移除过滤器之后相应的过滤器文件<br>public: 静态资源文件夹<br>router: Vue-router 前端路由文件<br>store: Vuex 存放组件状态<br>views: 页面组件<br>App.vue: 页面入口组件<br>main.js: 程序入口文件,加载路由,公共组件,组件状态</p>
<p>后端：<br><img src="./1484310479208.png" alt="Back-End"></p>
<p>bin: express的入口文件<br>config: 配置文件(数据库配置文件)<br>dao: 数据库操作<br>models: 抽象出来的模块(comment模块, post模块, user模块<br>nodes_modules: NPM包<br>public: 静态资源文件<br>router: 路由<br>views: 页面(无用)<br>app.js: express程序入口文件<br>packages.json: npm</p>
<p><strong>技术实现</strong></p>
<p>具体实现的功能:</p>
<ol>
<li>登录</li>
<li>注册</li>
<li>登出</li>
<li>查看发表的文章(三个板块: 前端, 网络. 安全)</li>
<li>发表文章</li>
<li>评论</li>
<li>点击量的统计</li>
</ol>
<p>拓展功能(未完成):</p>
<ol>
<li>当前用户页</li>
<li>点赞功能</li>
<li>评论部分@功能</li>
<li>文章或者评论被其他用户提到,自动提醒</li>
<li>其他</li>
</ol>
<p>webpack loader:</p>
<ol>
<li>vue-loader: 加载 vue 组件(值得一提的是Vue-loader自身并不具备解析任何文件的能力,它只是给Vue组件里面的资源分类,然后分配给相应的loader)</li>
<li>babel-loader: 编译ES6</li>
<li>json-loader: 自动解析json文件</li>
<li>url-loader: 配合file-loader一起使用</li>
<li>css相关loader: 编译css,并根据Can I Use自动添加前缀</li>
<li>Sass相关: 编译Scss文件,和Vue组件里面Scss语法</li>
<li>html-loader: 模板编译</li>
</ol>
<p>我这里面要管理的状态就是用户的登录状态,和记录一些当前用户的信息,因为考虑到到文章详情页的时候减少网络的请求,存储了一部分文章内容.但是感觉在文章请求优化上还是有点问题的,和点击量部分有点冲突(点击量的统计就是请求该文章数据库的请求次数)</p>
<h3 id="一些收货"><a href="#一些收货" class="headerlink" title="一些收货"></a>一些收货</h3><p>其实做完这个实践之后,里面的技术细节,好好琢磨琢磨文档完全没有问题.我下面就说说我踩的一些坑,和积累的一些知识.(后面是出处)</p>
<ol>
<li>vue-loader根本没有处理.vue文件里面的内容！根本没有！他只是告诉你应该由其他的方式来loader来处理这个文件.@<a href="https://segmentfault.com/a/1190000004944322" target="_blank" rel="external">吐槽一下vue-loader</a></li>
<li>Vuex会让你的Vue代码足够灵活可控，把数据统一存入state, 只允许通过Actions触发Mutations修改。然而，有时候我们的项目并没有复杂到需要用上Vuex。<br>这时候你可以考虑使用Event Bus。<br>但是Event Bus也存在一些隐患.@<a href="https://www.w3ctrain.com/2016/08/02/text-overflow-mutiple-line/" target="_blank" rel="external">Event Bus 在Vue中的使用</a></li>
<li>注意驼峰命名和连字符命名</li>
<li>vue-resource跨域请求数据的时候,后端设置cookie,前端无法解析的问题,要注意加上<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Vue.http.interceptors.push((request, next) =&gt; &#123;</div><div class="line">    request.credentials = true</div><div class="line">    next()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>后端加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">app.all(&apos;*&apos;,function (req, res, next) &#123;</div><div class="line">  res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://localhost:8080&apos;);</div><div class="line">  res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&apos;);</div><div class="line">  res.header(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT, POST, GET, DELETE, OPTIONS&apos;);</div><div class="line">  res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);</div><div class="line"></div><div class="line">  if (req.method == &apos;OPTIONS&apos;) &#123;</div><div class="line">    res.sendStatus(200);</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    next();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>本来用node-inspector来调试后端Nodejs,但是除了一些问题之后发现官方已经许久没有更新该工具了,偶然间看到这个调试Nodejs的方法@<a href="https://gold.xitu.io/entry/58005ab4128fe1005493b422" target="_blank" rel="external"><br>使用 Chrome 直接、并行调试 Node.js 及 JavaScript</a></p>
<p>###思考<br>如何划分组件比较合理?</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;迟来的Vuejs组件化实践总结&quot;&gt;&lt;a href=&quot;#迟来的Vuejs组件化实践总结&quot; class=&quot;headerlink&quot; title=&quot;迟来的Vuejs组件化实践总结&quot;&gt;&lt;/a&gt;迟来的Vuejs组件化实践总结&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;开始接触Vuejs是在2016年国庆的时候,正好赶上1.0过渡到2.0,也开始了正式的组件化编程.下面我做的简单的多人博客平台是期末考时候就差不多完成的,然后因为时间问题拖到现在才写下这篇总结,效果已经大打折扣…&lt;/p&gt;
&lt;h3 id=&quot;技术栈&quot;&gt;&lt;a href=&quot;#技术栈&quot; class=&quot;headerlink&quot; title=&quot;技术栈&quot;&gt;&lt;/a&gt;技术栈&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt; : Vuejs + Vuex + Vue-resource + Vue-router + Sass + webpack + ES6&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后端&lt;/strong&gt; : Nodejs + Express + MongoDB&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="http://code.mrwaite.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>[译] 前端2017性能优化清单</title>
    <link href="http://code.mrwaite.cn/2016/12/23/%E8%AF%91-%E5%89%8D%E7%AB%AF2017%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B8%85%E5%8D%95/"/>
    <id>http://code.mrwaite.cn/2016/12/23/译-前端2017性能优化清单/</id>
    <published>2016-12-23T15:27:16.000Z</published>
    <updated>2017-01-13T12:17:47.663Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.smashingmagazine.com/2016/12/front-end-performance-checklist-2017-pdf-pages/" target="_blank" rel="external">原文</a><br>By Vitaly Friedman<br>译 Mrwaite</p>
<p>你已经在使用渐进式启动了吗？那么React 和 Angular中的<code>tree-shaking</code>和<code>code-splitting</code>呢？你是否设置了 <a href="https://zh.wikipedia.org/wiki/Brotli" target="_blank" rel="external">Brotli</a> 或  <a href="https://zh.wikipedia.org/wiki/Zopfli" target="_blank" rel="external">Zopfli</a> 压缩,   <a href="https://zh.wikipedia.org/wiki/OCSP%E8%A3%85%E8%AE%A2" target="_blank" rel="external">OCSP</a> stapling,  <a href="https://http2.github.io/http2-spec/compression.html" target="_blank" rel="external">HPACK</a> 压缩呢？ 那么 <a href="https://www.keycdn.com/blog/resource-hints/" target="_blank" rel="external">Resource Hints</a>,  <a href="http://httpwg.org/http-extensions/client-hints.html" target="_blank" rel="external">Client Hints</a> 和 <a href="https://developers.google.com/web/updates/2016/06/css-containment" target="_blank" rel="external">CSS Containment </a> 呢？就更不用说 IPV6, HTTP/2,  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="external">Server Workers</a> 了。</p>
<p>早些时候，性能问题往往都是项目完成之后考虑的。经常被推迟到项目末期，它将会被归结为压缩， 合并， 资源优化以及对服务器的一些配置文件做细微的调整。<br>现在回头想想， 事情似乎已经发生了很大的变化。</p>
<p>性能并不只是技术上的考量，重要的是，当其融入到工作流当中时，设计理念往往通过性能的优劣来更好的展现。性能必须持续的测试，监控，优化。日益复杂的 Web 环境给我们带来了新的挑战，我们非常困难去检测具体的性能指标，因为性能指标的检测是非常依赖于终端设备， 浏览器，协议，网络类型以及潜在的一些东西（CDNs， ISPs， 缓存， 代理，防火墙，负载均衡和服务器，它们都在性能问题上扮演非常重要的角色）。</p>
<p>所以，如果我们实际环境中已经涉及到了上述的东西，那么从开始到网站最终的发布提升性能时这些的东西都应该考虑进去。这篇性能清单看上去如何？下面你将会得到一份（希望是公正的客观的）前端2017性能清单——上述问题你可能需要去考虑，以便确保网页响应时间够快，够流畅。</p>
<a id="more"></a>
<hr>
<p>[TOC]</p>
<p>微优化对于让性能保持正常状态是很有效的，但是关键是有清晰的目标——可行的目标将影响整个过程中做的任何决定。下面有一些不同的模型，每一个谈论的都是比较之后评价——确保早点设置自己的优先级。</p>
<p>文章提到一些性能指标名词：</p>
<ol>
<li>start rendering time ：用户在页面上看到的第一个内容的时间</li>
<li>first meaningful paint：页面展示其主要内容所需的时间</li>
<li>time to interactive： 一个页面——主要是单页面应用，加载充分，用户可以与其互动的时间线 </li>
</ol>
<h3 id="准备和设置目标"><a href="#准备和设置目标" class="headerlink" title="准备和设置目标"></a>准备和设置目标</h3><h4 id="1-比你的最快的竞争对手快-20-。"><a href="#1-比你的最快的竞争对手快-20-。" class="headerlink" title="1. 比你的最快的竞争对手快 20% 。"></a>1. 比你的最快的竞争对手快 20% 。</h4><p>根据<a href="https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/#the-need-for-performance-optimization-the-20-rule" target="_blank" rel="external">心理研究</a>，如果你想要用户感觉你的网站比其他的网站快，你至少需要快 <strong>20%</strong>。<br> 整页加载时间与像是<code>start rendering time</code>( 用户在页面上看到的第一个内容的时间 )等指标不相关，而与<a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint" target="_blank" rel="external"> first meaningful paint</a>（即页面展示其主要内容所需的时间）和 <a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" target="_blank" rel="external">time to interactive</a> (即 一个页面——主要是单页面应用，加载充分，用户可以与其互动的时间线) 有关。</p>
<p>在 一部 Moto G ，一部中档三星设备和一部像是 Nexus 4 这样的比较好的中档设备，优先在开放设备实验室（常规的 3G， 4G 和 WIFI）中，测试<code>start rendering time</code>（使用 <a href="http://www.webpagetest.org/" target="_blank" rel="external">WebPagetest</a>） 和  <code>first meaningful paint times</code> （使用 <a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="external">Lighthouse</a>）。<br><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/lighthouse_ykpzcd_c_scalew_546-opt.png" alt="enter image description here"></p>
<p><em>Lighthouse, a new performance auditing tool by Google.</em></p>
<p>查看你的分析数据，了解你的用户的所处的位置，之后你可以测试模拟 90% 的情况。 收集数据，建立一个<a href="http://danielmall.com/articles/how-to-make-a-performance-budget/" target="_blank" rel="external">spreadsheet</a>, 剔除 20% ，通过这样的方法设定你的目标（即 性能预算）。 现在你有些可以测试的东西。如果你保持预算，尝试压缩脚本，去得到一个比较快的<code>time-to-interactive</code> 值，那你就在一个合理的优化路径上。</p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/performance-budget_lbp9l7_c_scalew_1241-opt.png" alt="Performance budget builder by Brad Frost."></p>
<p><em><a href="http://bradfrost.com/blog/post/performance-budget-builder/" target="_blank" rel="external">Performance budget</a> builder by Brad Frost.</em></p>
<p>与你的同事分享这份清单。确保你的团队的每一位成员都熟悉它，以免带来不必要的误解。如果项目的每一个决策都有性能的考量，那概念，UX和视觉设计方案决定时，项目将会从积极参与的前端开发者上收获巨大。所以，对每一个设计决策，都要考虑性能预算和其在清单中定义的优先级。</p>
<h4 id="2-100毫秒的响应时间，每秒60帧。"><a href="#2-100毫秒的响应时间，每秒60帧。" class="headerlink" title="2. 100毫秒的响应时间，每秒60帧。"></a>2. 100毫秒的响应时间，每秒60帧。</h4><p><a href="https://www.smashingmagazine.com/2015/10/rail-user-centric-model-performance/" target="_blank" rel="external">RAIL performance model</a>给我们一些合理的目标：在初始输入之后，反馈时间应尽量少于100毫秒。为了实现小于100毫秒的响应时间，页面必须在50毫秒的时间内让主线程得到控制权。对于像动画一样需要频繁点击的，对于做不到小于100毫秒相应时间的地方，要做绝对的压缩！</p>
<p>而且，动画的每一帧应该在小于16毫秒的时间内完成，从而实现每秒60帧（1 秒 / 60 = 16.6 毫秒），最好小于10毫秒。因为在到达下一个16.6毫秒时间点之前你的代码应该被执行，这样浏览器才有时间去渲染新的帧。客户端应<a href="http://info.meteor.com/blog/optimistic-ui-with-meteor-latency-compensation" target="_blank" rel="external">Be optimistic</a>( 个人理解：客户端直接响应用户的交互,在客户端离线对用户行为进行推测 ) 以及聪明的利用空闲的时间。显而易见，这些目标适用于运行性能优化，对于加载性能优化不那么适用。</p>
<h4 id="3-First-meaningful-paint时间小于1-25秒，-SpeedIndex-小于-1000"><a href="#3-First-meaningful-paint时间小于1-25秒，-SpeedIndex-小于-1000" class="headerlink" title="3.  First meaningful paint时间小于1.25秒， SpeedIndex 小于 1000"></a>3.  <code>First meaningful paint</code>时间小于1.25秒， SpeedIndex 小于 1000</h4><p>虽然上面的要求可能很难实现，你的最终目标应该是在良好的网络连接状况下，<code>start rendering time</code>小于1秒以及<a href="https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index" target="_blank" rel="external">SpeedIndex</a>(显示页面的可见部分的平均时间)值应该小于1000。<br>对于移动端，在3G网络下，一个小于3秒的<code>start rendering time</code>才是可以被接受的。稍高于上面指标也是可以的，但是应当尽可能的低。</p>
<h3 id="明确环境"><a href="#明确环境" class="headerlink" title="明确环境"></a>明确环境</h3><h4 id="4-选择和设置构建工具"><a href="#4-选择和设置构建工具" class="headerlink" title="4.  选择和设置构建工具"></a>4.  选择和设置构建工具</h4><p>不要太过于关注这段时间感觉很酷的构建工具。构建工具依照于你当前的环境，选择 Grunt, Gulp, Webpack, PostCSS或者是一个组合工具。当你在上面选择中得出结果足够快，在维护构建过程中也没有出现问题的时候，那么这方面就做的不错了。</p>
<h4 id="5-渐进增强"><a href="#5-渐进增强" class="headerlink" title="5.  渐进增强"></a>5.  渐进增强</h4><p>保持渐进增强作为你前端体系结构的指导原则，那部署就是一个安全的赌注。首先设计和制定核心体验是什么，然后通过一些高级特性为功能强大的浏览器增强用户体验，创造弹性体验感。如果你的网站在比较差的屏幕，浏览器，网络和设备上运行的十分流畅，那在比较好的环境中只会运行更加流畅！</p>
<h4 id="6-Angular，-React，-Ember-和-co"><a href="#6-Angular，-React，-Ember-和-co" class="headerlink" title="6.  Angular， React， Ember 和 co"></a>6.  Angular， React， Ember 和 co</h4><p>喜欢能支持服务器端渲染的框架。在选择框架之前，确保测试服务器端渲染和客户端渲染在移动端的启动时间（因为改变框架之后， 测试性能问题将是比较困难的一件事）。如果你将要使用一个JavaScript框架，确保你的选择是经过<a href="https://www.youtube.com/watch?v=6I_GwgoGm1w" target="_blank" rel="external">比较</a>的和<a href="https://medium.com/@ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.h0r9v08lr" target="_blank" rel="external">深思熟虑</a>。不同的框架在性能上将会有不同的效果，当然会要求不同的优化策略，所以你必须清楚你将会依赖的框架的所有的细节组成。当构建一个web app， 可以看看 <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank" rel="external"> PRPL pattern </a> 和   <a href="https://developers.google.com/web/updates/2015/11/app-shell" target="_blank" rel="external">application shell architecture</a>.</p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/app-build-components_dibweb_c_scalew_1408-opt.png" alt="PRPL"></p>
<p><em>PRPL 表示推送关键资源， 渲染初始路由， 预缓存剩余路由 和  按需懒加载剩余路由.</em></p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/appshell-1_o0t8qd_c_scalew_1249-opt.jpg" alt=" application shell "></p>
<p><em>一个应用程序shell，是用最小的HTML， CSS， JavaScript提供一个用户界面</em></p>
<h4 id="7-AMP-or-Instant-Articles"><a href="#7-AMP-or-Instant-Articles" class="headerlink" title="7. AMP or Instant Articles"></a>7. AMP or Instant Articles</h4><p>取决于你团体的优先级和战略，你或许想要使用 Google 的 <a href="https://www.ampproject.org/" target="_blank" rel="external">AMP</a>  或者  Facebook 的  <a href="https://instantarticles.fb.com/" target="_blank" rel="external">Instant Articles</a>。没有它们，你也可以实现良好的性能展现。但是 <code>AMP</code> 通过免费的 <code>CDN</code> ，确实提供稳定的性能方案，而 <code>Instant Articles</code> 将会提高在Facebook上的性能表现。当然你也可以构建  <a href="https://www.smashingmagazine.com/2016/12/progressive-web-amps/" target="_blank" rel="external">progressive web AMPs</a> 。</p>
<h4 id="8-选择CDN"><a href="#8-选择CDN" class="headerlink" title="8.  选择CDN"></a>8.  选择CDN</h4><p>根据你拥有多少动态数据，你可以将内容的一部分放到一个<a href="https://www.smashingmagazine.com/2015/11/static-website-generators-jekyll-middleman-roots-hugo-review/" target="_blank" rel="external"> static site generator</a>上, 推送到CDN上，生成一个静态的资源版本，来减少数据库的请求。你甚至可以选择一个基于CDN的 <a href="https://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/" target="_blank" rel="external">static-hosting platform</a> ， 使用交互式组件增强你的页面（<a href="https://jamstack.org/" target="_blank" rel="external">JAMStack</a>）.</p>
<h3 id="构建优化"><a href="#构建优化" class="headerlink" title="构建优化"></a>构建优化</h3><h4 id="9-设置资源优先级"><a href="#9-设置资源优先级" class="headerlink" title="9.  设置资源优先级"></a>9.  设置资源优先级</h4><p>这是一个好的方法让你知道你首先需要解决的是什么。盘点你全部的资源（JavaScript, images, fonts, 第三方脚本和页面中“昂贵”的模块，像是轮播，复杂的信息图表，多媒体内容），并给它们分组。</p>
<p>建立一个电子表格。对旧版的浏览器定义最基本的核心体验（即 完全可以访问的核心内容），增强哪些功能更强大的浏览器的体验（即 更加丰富的体验）还有 额外的（资源并不需要第一时间全部加载，可以懒加载，像是web fonts，不必要的样式，轮播脚本，媒体播放器， 社交媒体按钮相关的， 大图片）。我们发布过一篇文章 “ <a href="https://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/" target="_blank" rel="external">Improving Smashing Magazine’s Performance</a> “, 里面讨论了这个优化方法的一些细节。</p>
<h4 id="10-使用-“cutting-the-mustard”-技术"><a href="#10-使用-“cutting-the-mustard”-技术" class="headerlink" title="10. 使用 “cutting-the-mustard” 技术"></a>10. 使用 “<code>cutting-the-mustard</code>” 技术</h4><p>使用 <a href="http://responsivenews.co.uk/post/18948466399/cutting-the-mustard" target="_blank" rel="external">cutting-the-mustard technique</a> 向旧版浏览器传递核心体验，向现代浏览器传递增强之后的体验方案。严格加载你的资源： 立即加载核心体验的代码，把增强部分加入到 <code>DomContentLoaded</code> 事件中，把 附加部分加入到 <code>load</code> 事件中。</p>
<p>值得注意的是该技术可以从浏览器版本推断设备能力的强弱，但是现在我们不能再这么干了。举个例子，廉价的安卓手机在发展中国家主要运行Chrome，虽然这些设备只拥有有限的内存和 CPU 能力，但也会使用 <code>cut the mustard</code> 技术。注意，当我们有没有别的选择时，使用该技术的局限性会越来越大。</p>
<h4 id="11-考虑微优化和渐进式启动"><a href="#11-考虑微优化和渐进式启动" class="headerlink" title="11. 考虑微优化和渐进式启动"></a>11. 考虑微优化和渐进式启动</h4><p>有些app在开始渲染页面之前需要先初始化app，可以渲染<a href="https://twitter.com/lukew/status/665288063195594752" target="_blank" rel="external"> skeleton screens</a>去代替加载指示器。因为大多数的性能问题源于启动app的初始解析时间，所以需要找到一些模块和技术去加速初始渲染的时间（ex：<a href="https://medium.com/@richavyas/aha-moments-from-ngconf-2016-part-1-angular-2-0-compile-cycle-6f462f68632e#.8b9afnsub" target="_blank" rel="external">tree-shaking</a> and <a href="https://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">code-splitting</a>）。也可以，使用<a href="https://www.lucidchart.com/techblog/2016/09/26/improving-angular-2-load-times/" target="_blank" rel="external">ahead-of-time compiler </a>将客户端渲染的负担分担到服务端，快速产生解析结果。最后，使用 <a href="https://github.com/nolanlawson/optimize-js" target="_blank" rel="external"> Optimize.js</a>包装急需调用的函数来加快初始加载（虽然，现在这点 <a href="https://twitter.com/tverwaes/status/809788255243739136" target="_blank" rel="external">不再是必须</a> 的了）。</p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/fmp-and-tti-opt.jpeg" alt="Progressive booting"></p>
<p><em><a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/" target="_blank" rel="external">Progressive booting</a>指的是使用服务器端渲染去得到一个快速的 <code>first meaningful paint</code> ,也包括使用一些最小的JavaScript脚本去让 <code>time-to-interactive</code> 时间接近 <code>first meaningful paint</code> 时间。</em></p>
<p>客户端渲染 or 服务器端渲染？不管什么场景，我么的目标都是建立<a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/" target="_blank" rel="external">Progressive booting</a>方案：使用服务器端渲染去得到一个理想的 <code>first meaningful paint</code> 时间，也包括使用一些最小的JavaScript脚本去让 <code>time-to-interactive</code> 时间接近 <code>first meaningful paint</code> 时间。我们也可以在需求或者时间允许的情况下，启动一些app非必要的部分。不幸的是，正如<a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/#which-to-use-progressive-booting" target="_blank" rel="external">Paul Lewis 注意到的</a>，框架通常没有优化的概念，这些都抛给了开发者。因此渐进式启动对于大部分的库和框架来说是很难实行的。如果你有时间和资源，使用这个方案去促进性能优化。</p>
<h4 id="12-正确设置HTTP-cache头部"><a href="#12-正确设置HTTP-cache头部" class="headerlink" title="12. 正确设置HTTP cache头部"></a>12. 正确设置HTTP cache头部</h4><p>再次检查一遍 <code>expires</code>, <code>cache-control</code>, <code>max-age</code> 和其他 HTTP cache 头部事都设置正确吗。通常，资源应该是可缓存的不管是短时间的（如果它们很可能改变），还是无限期的（如果它们是静态的）——你可以在需要更新的时候， 改变 URL 中它们的版本即可。</p>
<p>如果可能， 使用 <code>Cache-control: immutable</code>， 该头部为被打上指纹的静态资源设计，避免资源被重新验证（截至 2016年12月，只有 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="external">FireFox 在 HTTPS 中支持</a> ）。你也可以使用 <a href="https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers" target="_blank" rel="external">Heroku 的 HTTP 缓存头部</a>，Jake Archibald 的 <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="external"> “Caching Best Practices” </a>，以及  Ilya Grigorik 的 <a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en" target="_blank" rel="external">HTTP caching primer</a> 作为指导。</p>
<h4 id="13-限制第三方库和异步加载的JavaScript"><a href="#13-限制第三方库和异步加载的JavaScript" class="headerlink" title="13. 限制第三方库和异步加载的JavaScript"></a>13. 限制第三方库和异步加载的JavaScript</h4><p>当用户请求一个界面， 浏览器提取 HTML 文档创建 DOM 树，然后提取 CSS 样式表创建 CSSOM 树， 最后通过匹配 DOM 树上的节点和 CSSOM 树上对应的节点合并生成一棵渲染树。如果途中有任何的 JavaScript 需要执行， 浏览器会停止渲染直到该 JavaScript 执行完毕， 因此延缓页面的渲染（阻塞 DOM 构建）。作为开发者，我们必须明确的告诉浏览器不要再等待了，应当抓紧渲染页面。解决方案就是设置为 scripts 设置 <code>defer</code> 和 <code>async</code> 属性。</p>
<h4 id="14-正确的图片优化"><a href="#14-正确的图片优化" class="headerlink" title="14. 正确的图片优化"></a>14. 正确的图片优化</h4><p>尽可能的使用 <code>srcset</code>， <code>sizes</code> 和 <code>&lt;picture&gt;</code> 标签来实现 <a href="https://www.smashingmagazine.com/2014/05/responsive-images-done-right-guide-picture-srcset/" target="_blank" rel="external"> responsive images</a>。你也可以在 <code>&lt;picture&gt;</code> 标签和 一张JPEG图片作为后备（ Andreas Bovens的 <a href="https://dev.opera.com/articles/responsive-images/#different-image-types-use-case" target="_blank" rel="external"> code snippet</a>）来加载<a href="https://www.smashingmagazine.com/2015/10/webp-images-and-performance/" target="_blank" rel="external"> WebP 格式</a>图片。<br>或者使用 <code>Accrpt</code> 头部来和服务器交流。<code>Sketch</code> 支持 WebP格式， WebP图片在Photoshop中可以使用 <a href="http://telegraphics.com.au/sw/product/WebPFormat#webpformat" target="_blank" rel="external"> WebP plugin for Photoshop</a>  来导出。<a href="https://developers.google.com/speed/webp/docs/using" target="_blank" rel="external">Other options are available</a></p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/responsive-image-breakpoints-generator-750w-opt.jpeg" alt=""></p>
<p><em><a href="http://www.responsivebreakpoints.com/" target="_blank" rel="external">Responsive Image Breakpoints Generator </a> 可以自动化图像和标记的生成</em></p>
<p>你也可以使用  <a href="https://www.smashingmagazine.com/2016/01/leaner-responsive-images-client-hints/" target="_blank" rel="external">client hints</a> , 目前还在获得 <a href="http://caniuse.com/#search=client-hints" target="_blank" rel="external">浏览器的支持</a> 。没有足够的资源来支持响应式图片的复杂标记？使用 <a href="http://www.responsivebreakpoints.com/" target="_blank" rel="external"> Responsive Image Breakpoints Generator </a> 或者像是<a href="http://cloudinary.com/documentation/api_and_access_identifiers" target="_blank" rel="external">Cloudinary</a>这样的服务来自动化图片的优化。此外，在许多情况下，单独使用 <code>srcset</code> 或 <code>sizes</code> 将会收获显著。 在Smashing杂志中，我们使用 后缀<code>-opt</code> 作为图像名称 - 例如， <code>brotli-compression-opt.png</code>, 这样只要图像包含这样的后缀，团队中的每个人都知道该图像被优化过了。</p>
<h4 id="15-让图像优化提高到下一个水平"><a href="#15-让图像优化提高到下一个水平" class="headerlink" title="15. 让图像优化提高到下一个水平"></a>15. 让图像优化提高到下一个水平</h4><p>当在你着手的一个登录页面中，非常紧急的需要一个特定的图像加载的足够的快，这时候你需要确保 JPEGs 通过 <a href="https://github.com/mozilla/mozjpeg" target="_blank" rel="external"> mozJPEG</a> （mozJPEG可以提高图片的初始渲染时间，通过操纵扫描级别）来优化 和 压缩，PNG 使用 <a href="http://css-ig.net/pingo" target="_blank" rel="external">Pingo</a> , GIF 使用 <a href="https://kornel.ski/lossygif" target="_blank" rel="external"> Lossy GIF</a>, SVG 使用 <a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="external">SVGOMG</a>。模糊图片不必要的部分（通过应用高斯模糊过滤它们）来减少文件的体积，最终你甚至可以通过着手删除颜色或用黑白呈现图片进一步减少体积。对于背景图片，从Photoshop导出时候减少 0 ~ 10% 的质量也是完全可以接受的。</p>
<p>还不够？那好，也可以通过<a href="http://csswizardry.com/2016/10/improving-perceived-performance-with-multiple-background-images/" target="_blank" rel="external">multiple</a> <a href="https://jmperezperez.com/medium-image-progressive-loading-placeholder/" target="_blank" rel="external">background</a> <a href="https://manu.ninja/dominant-colors-for-lazy-loading-images#tiny-thumbnails" target="_blank" rel="external">images</a> <a href="https://css-tricks.com/the-blur-up-technique-for-loading-background-images/" target="_blank" rel="external">technique</a>（这里面每个单词都是一个链接）来提高图像的感觉性能。</p>
<h4 id="16-web-fonts-优化"><a href="#16-web-fonts-优化" class="headerlink" title="16. web fonts 优化"></a>16. web fonts 优化</h4><p>你是用的web fonts很可能包含未使用的字形和额外的功能。如果你用的是 open-source fonts ，你可以向你的类型产生工厂要求一个web fonts子集或者自己<a href="https://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="external">产生一个</a>来减少文件的体积。能支持WOFF2最好，对不支持的浏览器你也可以使用 WOFF 和OTF 作为降级处理的方案。另外，从Zach Leatherman’s <a href="https://www.zachleat.com/web/comprehensive-webfonts/" target="_blank" rel="external">Comprehensive Guide to Font-Loading Strategies</a> 方案 和 <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjB26L3i4jRAhVnxFQKHQ1RAB4QFggcMAA&amp;url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FService_Worker_API&amp;usg=AFQjCNGcFYqcUoZIpTlw41JzGxE8aGJntw&amp;sig2=HCdwMGD6vwAe8s0o2SAzFw" target="_blank" rel="external">service worker</a>来永久缓存字体，来选择一种方案。需要快速的效果？Pixel Ambacht 有一个<a href="https://pixelambacht.nl/2016/font-awesome-fixed/" target="_blank" rel="external">快速的教程和案例分析</a>去获取指定的字体。</p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/zach-web-fonts_c8nq74_c_scalew_1528-opt.png" alt=""></p>
<p><em>Zach Leatherman’s Comprehensive Guide to Font-Loading Strategies 为web fonts交付提供了十几个的选项</em></p>
<p>如果你不能从自己的服务上使用字体，而是依赖第三方，那就确保使用<a href="https://github.com/typekit/webfontloader" target="_blank" rel="external"> Web Font Loader</a>。 <a href="https://www.filamentgroup.com/lab/font-events.html" target="_blank" rel="external">FOUT 比 FOIT 好</a>; 降级处理中，首先渲染文本，后异步加载字体——你也可以使用 <a href="https://github.com/filamentgroup/loadCSS" target="_blank" rel="external">loadCSS</a>。<br>你也应该<a href="https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/" target="_blank" rel="external">远离本地安装的系统字体</a>。</p>
<h4 id="17-快速推送-critical-CSS-样式"><a href="#17-快速推送-critical-CSS-样式" class="headerlink" title="17. 快速推送 critical CSS 样式"></a>17. 快速推送 critical CSS 样式</h4><p>为了确保浏览器尽可能快的渲染你的页面，收集渲染页面第一个可见部分需的CSS（“critical CSS” or  “above-the-fold CSS”）以及把他添加到 <code>&lt;head&gt;</code> 标签的中来减少请求往返 ，已经变成通常做法。因为在 TCP 慢启动阶段交换的数据包大小有限制，所以你对于 critical CSS 大小的预算是 大约 14 KB。如果超过了这个预算，浏览器需要额外的 HTTP 往返去获取 critical CSS 样式。<a href="https://github.com/filamentgroup/criticalCSS" target="_blank" rel="external">CriticalCSS</a> 和 <a href="https://github.com/addyosmani/critical" target="_blank" rel="external">Critical</a> 可以确保你在预算之内。在每一个你使用的模版当中你都应该去做这件事。如果可能， 考虑使用 <a href="https://www.filamentgroup.com/lab/performance-rwd.html" target="_blank" rel="external">conditional inlining approach</a> ，其已被 the Filament Group 使用。</p>
<p>在 HTTP/2中，为了避免一个产生臃肿的HTML文件, critical CSS应该被存储在一个分离的CSS 文件中并通过服务器推送。但是服务器端推送支持并不一致，而且还有一些还存放方面的问题（查看  <a href="http://www.slideshare.net/Fastly/http2-what-no-one-is-telling-you" target="_blank" rel="external">Hooman Beheshti’s presentation</a>）。事实上，这影响是负面的，会膨胀网络的缓冲区，导致文档当中真正的帧无法被递送。因为 TCP 的慢启动，服务器端推送 <a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit" target="_blank" rel="external">在热连接上更加高效</a>。 记住，<code>cache-digest</code> 这个高速缓存的新规范将会否定手动创建 <code>&quot;cache-aware&quot;</code> 服务的需求。</p>
<h4 id="18-使用-tree-shaking-和-code-splitting-减少有效负载"><a href="#18-使用-tree-shaking-和-code-splitting-减少有效负载" class="headerlink" title="18.  使用 tree-shaking 和 code-splitting 减少有效负载"></a>18.  使用 tree-shaking 和 code-splitting 减少有效负载</h4><p><a href="https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf" target="_blank" rel="external">tree-shaking</a> 是一种，通过只加载生产中确实被使用的代码，来整理你构建过程的方法。你可以使用 <a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html" target="_blank" rel="external">Webpack2中清除未使用的部分</a>, 也可以使用<a href="https://github.com/giakki/uncss" target="_blank" rel="external">UnCSS</a> 或者 <a href="https://github.com/geuis/helium-css" target="_blank" rel="external">Helium</a> 去删除未使用CSS样式。另外， 你可能会考虑怎么去 书写 <a href="http://csswizardry.com/2011/09/writing-efficient-css-selectors/" target="_blank" rel="external">高效的 CSS 选择器</a> 或是怎么<a href="https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/" target="_blank" rel="external">避免 冗长 低效的样式</a>。</p>
<p><a href="https://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">Code-splitting </a> 是另一种Webpack特性，可以基于“chunks”分割你的代码然后按需加载这些代码块。一旦你在你的代码中确定了分割点，Webpack会全全负责这些依赖关系和输出文件。在应用发送请求的时候，这样基本上确保初始的下载足够小并且实现按需加载。</p>
<p>值得注意的是相比于 Browserify 输出结果  <a href="http://rollupjs.org/" target="_blank" rel="external"> Rollup</a>展现的更加优秀。当使用 Rollup时，我们会想要查看 <a href="https://github.com/nolanlawson/rollupify" target="_blank" rel="external"> Rollupify</a>，它可以转化 ECMAScript 2015 modules 为一个大的 CommonJS module——因为取决于打包工具和模块加载系统的选择，小的模块会有<a href="https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/" target="_blank" rel="external">令人惊讶的高性能开销</a>。</p>
<h4 id="19-提高渲染性能"><a href="#19-提高渲染性能" class="headerlink" title="19. 提高渲染性能"></a>19. 提高渲染性能</h4><p>使用<a href="http://caniuse.com/#search=contain" target="_blank" rel="external"> CSS containment</a> 隔离高代价的组件,比如限制一些画布外导航的布局 绘制的样式 或者第三方窗口小部件的样式的范围。确保在页面滚动或元素执行动画效果的时候，页面是没有滞后的，这样你就可以让页面每秒60帧一直保持一致。如果上面实现还是很困难，但至少让每秒的帧数保持在60 ~ 15的混合范围内。<br>使用 CSS 的 <a href="http://caniuse.com/#feat=will-change" target="_blank" rel="external">will-change</a> 去通知浏览器哪个元素或属性将要改变。</p>
<p>另外， 测试 <a href="https://aerotwist.com/blog/my-performance-audit-workflow/#runtime-performance" target="_blank" rel="external">运行渲染性能</a> （例如， <a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/" target="_blank" rel="external">in DevTools</a>）。在开始之前，请浏览 Paul Lewis 免费的 <a href="https://www.udacity.com/course/browser-rendering-optimization--ud860" target="_blank" rel="external"> Udacity 课程对于浏览器渲染优化</a> 的建议。我们还有一篇由  Sergey Chikuyonok 撰写的关于 如何<a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/" target="_blank" rel="external">正确获取 GPU 动画</a>的文章。</p>
<h4 id="20-通过预热连接加速传输"><a href="#20-通过预热连接加速传输" class="headerlink" title="20.  通过预热连接加速传输"></a>20.  通过预热连接加速传输</h4><p>使用 <code>skeleton  screens</code>， 懒加载所有的高代价的组件，像是字体， JavaScript， 轮播， 媒体和 iframes。使用 <a href="https://w3c.github.io/resource-hints" target="_blank" rel="external"> resource hints</a> 中一些方法节约加载时间：  <a href="http://caniuse.com/#search=dns-prefetch" target="_blank" rel="external">dns-prefetch </a>（在后台执行 DNS 查找） ,<a href="http://www.caniuse.com/#search=preconnect" target="_blank" rel="external">preconnect</a> (告知浏览器在后台开始一些握手协议（DNS， TCP， TLS）的连接)， <a href="http://caniuse.com/#search=prefetch" target="_blank" rel="external">prefetch</a> （要求浏览器去预取指定资源，是资源加载更快速）， <a href="http://caniuse.com/#search=prerender" target="_blank" rel="external"> prerender</a> （告知浏览器在后台渲染特定的页面）和 <a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/" target="_blank" rel="external">preload</a> （预取一些尚未开始执行的资源，包括一些其他东西）。值得注意的是实践当中，因为取决于浏览器的支持情况， 推荐 <code>dns-prefetch</code> 而不是 <code>preconnect</code>，而且应当谨慎的使用 <code>prefetch</code> 和 <code>prerender</code> ——后者只能在你对用户下一步将会浏览什么很自信时候才去使用（例如，在一个购买流程当中的时候）。</p>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><h4 id="21-准备好迎接-HTTP-2"><a href="#21-准备好迎接-HTTP-2" class="headerlink" title="21.  准备好迎接 HTTP/2"></a>21.  准备好迎接 HTTP/2</h4><p>随着 Google 一直向着<a href="https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html" target="_blank" rel="external">更加安全的 web</a> 发展 ，最终在 Chrome 中所有的 HTTP 网页将会被认为是“不安全”的，你将会需要去衡量是否继续在 HTTP/1.1 上做赌注，还是建立 <a href="https://http2.github.io/faq/" target="_blank" rel="external">HTTP/2 环境</a> 。 HTTP/2 已经被<a href="http://caniuse.com/#search=http2" target="_blank" rel="external">很好的支持</a>了。在大多数情况下，你最好使用它，这将是意义重大的，你迟早会把方向转移到 HTTP/2 的。最重要的是，通过 <code>service workers</code> 和 <code>server push</code> （至少长期）<a href="https://www.youtube.com/watch?v=RWLzUnESylc&amp;t=1s&amp;list=PLNYkxOF6rcIBTs2KPy1E6tIYaWoFcG3uj&amp;index=25" target="_blank" rel="external">性能将会有巨大的的飞跃</a>。</p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/http-pages-chrome-opt.png" alt=""> </p>
<p><em>最终， Google 计划标记所有的 HTTP 页面为不安全的，改变 HTTP 网页原有的安全标志为红色的警告，示意为损坏的 HTTPS。</em></p>
<p>缺点就是你需要去迁移到 HTTP/2 ，取决于使用 HTTP/1.1 用户数量有多大（就是使用旧版操作体统或使用旧版浏览器的用户），需要你发送不同的构建文件，这将要求你适应<a href="https://rmurphey.com/blog/2015/11/25/building-for-http2" target="_blank" rel="external">不同的构建流程</a> 。注意： 迁移和建立新的构建流程将会是棘手和费时的。文章剩余的部分，我将会假设你是正在切换或已经切换到 HTTP/2 了。</p>
<h4 id="22-正确部署-HTTP-2"><a href="#22-正确部署-HTTP-2" class="headerlink" title="22. 正确部署 HTTP/2"></a>22. 正确部署 HTTP/2</h4><p>其次，通过 <a href="https://www.youtube.com/watch?v=yURLTwZ3ehk" target="_blank" rel="external">HTTP/2 提供资源</a><br>将是一次巨大的翻新，与以往获取资源的方式相去胜远。你需要在模块打包和并行加载好多小模块中做出比较好的权衡。</p>
<p>一方面，你也许想要避免一次获取全部的资源，而是将整个界面拆分成好多小模块，把他们作为构建过程的一部分压缩，可以参考 <a href="https://rmurphey.com/blog/2015/11/25/building-for-http2" target="_blank" rel="external"> “scout” approach</a> 和 并行加载。其中一个文件有改动的时候不用重新下载整个样式表或者JavaScript文件。</p>
<p>另一方面，打包依旧很重要，因为向浏览器发送很多小 JavaScript 文件将会存在很多问题。首先，压缩是受损的。使用 字符重用 （相关：LZW压缩算法）有利于 大 包 的压缩。而不利于分离的小 包 的压缩。这方面的标准也有一些标准，但现在离我们还是太远了。其次，浏览器并未对这方面的工作流进行优化。举个例子，Chrome 将会根据资源数触发相应数量的<a href="https://www.chromium.org/developers/design-documents/inter-process-communication" target="_blank" rel="external">inter-process communications</a>(IPCs) ,， 所以包含数百个资源将会有浏览器的运行成本。</p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/progressive-css-loading-opt.png" alt=""></p>
<p><em>为了使用 HTTP/2 实现最佳效果， 参考 Chrome’s Jake Archibald 的建议，<a href="https://jakearchibald.com/2016/link-in-body/" target="_blank" rel="external">逐步加载css</a> </em></p>
<p>你也可以尝试 <a href="https://jakearchibald.com/2016/link-in-body/" target="_blank" rel="external">逐步加载css</a>。明显的，你这样做对于 HTTP/1.1 用户是不友好的， 所以作为你部署流程的一部分，你需要对不同的浏览器产生不同的构建方式，当然事情也会变得略显复杂。你也可以放弃 <a href="https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/" target="_blank" rel="external">  HTTP/2 connection coalescing</a>， 得益于 HTTP/2 ，允许你使用域分片，但是这个具体实现还是有点难度的。</p>
<p>怎么去做？如果你已运行在 HTTP/2， 作为妥协（对于旧版浏览器来说不算很坏），可以发送了大约10个包。当然对于自己的网站，还是需要实验和测试出合适的值是多少。</p>
<h4 id="23-确保服务的安全性"><a href="#23-确保服务的安全性" class="headerlink" title="23. 确保服务的安全性"></a>23. 确保服务的安全性</h4><p>所有浏览器的都是依赖 TLS 实现 HTTP/2 的 ，所以你可能想要避免安全性警告或有些网页无法工作。再次检查你的 <a href="https://securityheaders.io/" target="_blank" rel="external">正确设置安全性头部</a> ，<a href="https://www.smashingmagazine.com/2016/01/eliminating-known-security-vulnerabilities-with-snyk/" target="_blank" rel="external">消除已知漏洞</a> ， <a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="external">检查你的证书</a>。</p>
<p>已经迁移到 HTTPS了吗？查阅  <a href="https://https.cio.gov/faq/" target="_blank" rel="external">The HTTPS-Only Standard</a> ，以获取完整的指南。另外，确保所有的外部插件和跟踪脚本通过 HTTPS 加载，跨域脚本是不被允许的，<a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet" target="_blank" rel="external">HTTP Strict Transport Security headers</a> 和 <a href="https://content-security-policy.com/" target="_blank" rel="external"> Content Security Policy headers</a> 被正确设置。</p>
<h4 id="24-服务和-CNDs-支持-HTTP-2"><a href="#24-服务和-CNDs-支持-HTTP-2" class="headerlink" title="24. 服务和 CNDs 支持 HTTP/2 ?"></a>24. 服务和 CNDs 支持 HTTP/2 ?</h4><p>不同的服务和 CDNs 支持 HTTP/2 的程度是不一样的。使用 <a href="https://istlsfastyet.com/" target="_blank" rel="external"> Is TLS Fast Yet?</a>去查看符合你的选项，快速查看你服务的性能如何，支持哪些特性。</p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/isitfastyet_doieve_c_scalew_1393-opt.png" alt=""></p>
<p><em><a href="https://istlsfastyet.com/" target="_blank" rel="external"> Is TLS Fast Yet?</a> 允许你查看当你切换到 HTTP/2 时 你的服务和CDNs支持的选项。</em></p>
<h4 id="25-Brotli-or-Zopfli-compression"><a href="#25-Brotli-or-Zopfli-compression" class="headerlink" title="25.  Brotli or Zopfli compression"></a>25.  Brotli or Zopfli compression</h4><p> 去年，Google <a href="https://opensource.googleblog.com/2015/09/introducing-brotli-new-compression.html" target="_blank" rel="external">介绍</a>了 <a href="https://github.com/google/brotli" target="_blank" rel="external">Brotli</a>， 一个新的开源无损数据格式，已被Chrome， FireFox，Opera <a href="http://caniuse.com/#search=brotli" target="_blank" rel="external">广泛支持</a>。 实践中，Brotli 相比于 Gzip 和 Defalte 表现<a href="https://samsaffron.com/archive/2016/06/15/the-current-state-of-brotli-compression" target="_blank" rel="external">更加有效</a>。取决于设置，它可能会缓慢压缩，但是缓慢压缩最终导致高压缩率。而且，Brotli 解压是非常迅速的。因为是来源于Google的算法，那么对于浏览器只对用户浏览的HTTPS网页支持Brotli也就不奇怪了——好吧，其实里面也有一些技术上的原因。。。现今 Brotli 不是预先安装在大部分服务器上的，而且没有自编译的 NGINX 或 Ubuntu也不是那么容易安装 Brotli。然而，你甚至可以 <a href="http://calendar.perfplanet.com/2016/enabling-brotli-even-on-cdns-that-dont-support-it-yet/" target="_blank" rel="external">在不支持 Brotli 的CDNs上启用它</a>（使用的是 service worker 技术）。</p>
<p>或者，你可以去瞧瞧<a href="https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/" target="_blank" rel="external"> Zopfli 压缩算法</a>，它可以把数据编码成 Deflate， Gzip，Zlib格式。任何传统的 Gzip压缩资源，将会从 Zopfli 改进的 Deflate 编码方式中受益，因为文件将会比以 Zlib 最大的压缩方式压缩的文件小 3% ~ 8%。值得一提的是，文件将花费80倍的时间来压缩。这就是为什么推荐对那些不是经常改动的文件使用 Zopfli 压缩。</p>
<h4 id="26-启用了-OCSP-stapling-吗？"><a href="#26-启用了-OCSP-stapling-吗？" class="headerlink" title="26. 启用了 OCSP stapling 吗？"></a>26. 启用了 OCSP stapling 吗？</h4><p>通过在你的服务器上<a href="https://www.digicert.com/enabling-ocsp-stapling.htm" target="_blank" rel="external">启用 OCSP stapling</a>， 你可以加速 TLS 握手。<code>The Online Certificate Status Protocol</code> (OCSP)被 创建为替代 <code>the Certificate Revocation List</code> (CRL) 的方案。这两个协议被用作检查 SSL 证书是否被撤销。然而，<code>the OCSP protocol</code> 不要求浏览器下载，而是在列表中搜索证书的相关信息，因此减少了握手中的请求时间。</p>
<h4 id="27-你已经采用-IPv6-了？"><a href="#27-你已经采用-IPv6-了？" class="headerlink" title="27.  你已经采用 IPv6 了？"></a>27.  你已经采用 IPv6 了？</h4><p>因为我们正在<a href="https://en.wikipedia.org/wiki/IPv4_address_exhaustion" target="_blank" rel="external">耗尽 IPv4 空间</a> ，主要的移动网络正在迅速的支持 IPv6（美国已经有 <a href="https://www.google.com/intl/en/ipv6/statistics.html#tab=ipv6-adoption&amp;tab=ipv6-adoption" target="_blank" rel="external">50%</a> 的采用了 IPv6）。建议更新你的 DNS 到 IPv6，紧跟时代趋势。只需要确保网络提供 <code>dual-stack</code> 支持 —— 它允许 IPv6 和 IPv4 同时互不干涉的运行。但是终究，IPv6是不向后兼容的。而且，<a href="https://www.cloudflare.com/ipv6/" target="_blank" rel="external">研究显示</a> IPv6 凭借  neighbor discovery (NDP)  和 路由优化 让网站运行块 10% ~ 15%。</p>
<h4 id="28-启用了-HPACK-压缩？"><a href="#28-启用了-HPACK-压缩？" class="headerlink" title="28.  启用了 HPACK 压缩？"></a>28.  启用了 HPACK 压缩？</h4><p>如果你正在使用 HTTP/2 ， 为了减少不必要的开销，再次检查是否启用了 HPACK 压缩 HTTP 响应头部。因为 HTTP/2 服务还是相对来说比较新的，他们不一定完全支持规范，使用   HPACK 就是一个例子。 <a href="https://github.com/summerwind/h2spec" target="_blank" rel="external">H2spec </a> 是一个检查上述支持情况的比较好的工具。 <a href="https://www.keycdn.com/blog/http2-hpack-compression/" target="_blank" rel="external"> HPACK works</a>.</p>
<p><img src="https://www.smashingmagazine.com/wp-content/uploads/2016/12/h2spec-example-750w-opt.png" alt=""></p>
<p><em>H2spec（<a href="https://www.smashingmagazine.com/wp-content/uploads/2016/12/h2spec-example-large-opt.png" target="_blank" rel="external">View large version</a>）</em></p>
<h4 id="29-为缓存和网络降级启用-service-workers-了？"><a href="#29-为缓存和网络降级启用-service-workers-了？" class="headerlink" title="29.  为缓存和网络降级启用 service workers 了？"></a>29.  为缓存和网络降级启用 service workers 了？</h4><p>任何对于网络的性能优化都不可能比用户机器上本地存储缓存来的快。如果你的网站启用了 HTTPS， 使用 <a href="https://github.com/lyzadanger/pragmatist-service-worker" target="_blank" rel="external">Pragmatist’s Guide to Service Workers</a>在 <code>service worker cache</code> 和 离线存储（甚至完全离线的页面） 中 缓存静态资源，这样可以从用户本机上检索资源，而不是去网络上请求。参考：Jake’s <a href="https://jakearchibald.com/2014/offline-cookbook/" target="_blank" rel="external">Offline Cookbook</a> 和 the free Udacity course <a href="https://www.udacity.com/course/offline-web-applications--ud899" target="_blank" rel="external">Offline Web Applications</a> 。浏览器支持吗？看<a href="http://caniuse.com/#search=serviceworker" target="_blank" rel="external">这里</a>, 不管网络状况如何，这样的后备方案都是适用的。</p>
<h3 id="测试和监控"><a href="#测试和监控" class="headerlink" title="测试和监控"></a>测试和监控</h3><h4 id="30-监控混合内容的警告"><a href="#30-监控混合内容的警告" class="headerlink" title="30. 监控混合内容的警告"></a>30. 监控混合内容的警告</h4><p>如果你最近已经从 HTTP 迁移到了HTTPS， 请务必使用工具<a href="https://report-uri.io/" target="_blank" rel="external">Report-URI.io.</a>监控主动的和被动的混合内容警告。你也可以为混合内容，使用 <a href="https://github.com/bramus/mixed-content-scan" target="_blank" rel="external"> Mixed Content Scan</a> 去扫描支持 HTTPS 的站点。</p>
<h4 id="31-在-DevTools-中优化了你的开发工作流吗？"><a href="#31-在-DevTools-中优化了你的开发工作流吗？" class="headerlink" title="31.  在 DevTools 中优化了你的开发工作流吗？"></a>31.  在 DevTools 中优化了你的开发工作流吗？</h4><p>挑选一个调试工具，然后点击每一个简单的按钮。请确保自己能理解怎么去分析渲染性能和  console 输出，还有怎么去调试 JavaScript 和编辑 CSS 样式。Umar Hansa 最近准备了一个（很大的）<a href="https://umaar.github.io/devtools-optimise-your-web-development-workflow-2016/#/" target="_blank" rel="external">slidedeck</a> 和 <a href="https://www.youtube.com/watch?v=N33lYfsAsoU" target="_blank" rel="external">talk</a> 覆盖了几十个隐藏的提示和技术，能帮助我们更好的在 DevTools 中调试和测试。</p>
<h4 id="32-你在代理浏览器和旧版浏览器中测试过吗？"><a href="#32-你在代理浏览器和旧版浏览器中测试过吗？" class="headerlink" title="32.  你在代理浏览器和旧版浏览器中测试过吗？"></a>32.  你在代理浏览器和旧版浏览器中测试过吗？</h4><p>在 Chrome 和 FireFox 中测试是不够的。研究你的网站是怎么在代理浏览器和旧版浏览器中工作的。例如， UC 浏览器 和 Opera Mini ，在亚洲占着<a href="http://gs.statcounter.com/#mobile_browser-as-monthly-201511-201611" target="_blank" rel="external">一定的市场份额</a>（高达 35%），测试你感兴趣的国家<a href="https://www.webworldwide.io/" target="_blank" rel="external">网速的平均值</a>， 避免以后听说的时候被惊讶到。使用网络节流调节测试，来模仿高DPI的设备。<a href="https://www.browserstack.com/" target="_blank" rel="external"> BrowserStack</a>，就是一个非常棒的工具，也可以在真实设备商测试。</p>
<h4 id="33-建立了持续的监控？"><a href="#33-建立了持续的监控？" class="headerlink" title="33.  建立了持续的监控？"></a>33.  建立了持续的监控？</h4><p>有一个有用的私有地实例 <a href="http://www.webpagetest.org/" target="_blank" rel="external">WebPagetest</a>可以快速无限制的被测试。建立一个可以自动报警的持续性能预算监控。设置你自己的用户时间标记去测试  监控业务特定的指标。查看使用 <a href="https://speedcurve.com/" target="_blank" rel="external">SpeedCurve</a> 监控随着时间推移的性能的改变，使用 <a href="https://newrelic.com/browser-monitoring" target="_blank" rel="external">New Relic</a> 得到 <code>WebPagetest</code>不能提供的数据。还有一些工具：<a href="https://speedtracker.org/" target="_blank" rel="external">SpeedTracker</a> ，<a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="external">Lighthouse</a> ， <a href="https://calibreapp.com/" target="_blank" rel="external">Calibre</a>。</p>
<h3 id="快速获取："><a href="#快速获取：" class="headerlink" title="快速获取："></a>快速获取：</h3><p>这份清单还是相当全面的，完成所有的优化手段会需要相当一段时间的。所以，你只有1小时的时间，想去取得性能上显著的提升，应该怎么做？我们把它们合到 10 个 比较容易的方案上。当然，在你开始之前和完成之后，需要在 3G网络 和 有线网络中，分别测试 <code>start rendering time</code> 和 <code>SpeedIndex</code> 两个指标的值。</p>
<ol>
<li>你的目标是 <code>start rendering time</code> 在有线网络中小于 1 秒，在 3G 网络中小于 3 秒，和 <code>SpeedIndex</code> 值低于1000。然后优化 <code>start rendering time</code> 和 <code>time-to-interactive</code> 两个值。</li>
<li>为你的模版准备 <code>critical CSS</code> ，将其包含在页面 <code>&lt;head&gt;</code>标签内。（你的关键CSS大小预算是 14KB）。</li>
<li>尽可能延迟和懒加载尽量多的 scripts ，以及你的和第三方的 scripts —— 特别是社交媒体按钮相关的，视频播放相关的和高代价的JavaScript。</li>
<li>添加资源提示加速传输：<code>dns-lookup</code>, <code>preconnect</code>, <code>prefetch</code>, <code>preload</code> 和 <code>prerender</code>。</li>
<li>添加 web fonts 子集以及异步加载它们（或只切换到系统字体）。</li>
<li>优化图片，对关键页面图片使用 WebP 格式（像是登录页面）。</li>
<li>检查是否正确设置 HTTP 缓存头部和安全性头部。</li>
<li>在服务上启用 Brotli 或 Zopfli 压缩。（如果这不现实，也不要忘记 Gzip 压缩）</li>
<li>如果 HTTP/2 可用，启用   HPACK 压缩 和 监控混合内容的警告。如果你运行了 LTS， 别忘了启用 OCSP stapling。</li>
<li>如果可能，在  service worker 缓存中，缓存像是字体，样式，JavaScript，图片这样的资源——其实是，缓存越多越好！。</li>
</ol>
<h3 id="Off-We-Go！"><a href="#Off-We-Go！" class="headerlink" title="Off We Go！"></a>Off We Go！</h3><p>有些优化手段可能超出了你工作的范围，预算或是你负责的被遗弃的遗留代码范畴。没关系！把这份清单作为一般（希望是全面的）的指南，根据你实际的情况，列出你自己的问题列表。但是最最重要的是，在优化之前测试和监控你的项目，发现性能问题所在。最后希望大家，2017年有一个快乐的性能体验！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.smashingmagazine.com/2016/12/front-end-performance-checklist-2017-pdf-pages/&quot;&gt;原文&lt;/a&gt;&lt;br&gt;By Vitaly Friedman&lt;br&gt;译 Mrwaite&lt;/p&gt;
&lt;p&gt;你已经在使用渐进式启动了吗？那么React 和 Angular中的&lt;code&gt;tree-shaking&lt;/code&gt;和&lt;code&gt;code-splitting&lt;/code&gt;呢？你是否设置了 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Brotli&quot;&gt;Brotli&lt;/a&gt; 或  &lt;a href=&quot;https://zh.wikipedia.org/wiki/Zopfli&quot;&gt;Zopfli&lt;/a&gt; 压缩,   &lt;a href=&quot;https://zh.wikipedia.org/wiki/OCSP%E8%A3%85%E8%AE%A2&quot;&gt;OCSP&lt;/a&gt; stapling,  &lt;a href=&quot;https://http2.github.io/http2-spec/compression.html&quot;&gt;HPACK&lt;/a&gt; 压缩呢？ 那么 &lt;a href=&quot;https://www.keycdn.com/blog/resource-hints/&quot;&gt;Resource Hints&lt;/a&gt;,  &lt;a href=&quot;http://httpwg.org/http-extensions/client-hints.html&quot;&gt;Client Hints&lt;/a&gt; 和 &lt;a href=&quot;https://developers.google.com/web/updates/2016/06/css-containment&quot;&gt;CSS Containment &lt;/a&gt; 呢？就更不用说 IPV6, HTTP/2,  &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API&quot;&gt;Server Workers&lt;/a&gt; 了。&lt;/p&gt;
&lt;p&gt;早些时候，性能问题往往都是项目完成之后考虑的。经常被推迟到项目末期，它将会被归结为压缩， 合并， 资源优化以及对服务器的一些配置文件做细微的调整。&lt;br&gt;现在回头想想， 事情似乎已经发生了很大的变化。&lt;/p&gt;
&lt;p&gt;性能并不只是技术上的考量，重要的是，当其融入到工作流当中时，设计理念往往通过性能的优劣来更好的展现。性能必须持续的测试，监控，优化。日益复杂的 Web 环境给我们带来了新的挑战，我们非常困难去检测具体的性能指标，因为性能指标的检测是非常依赖于终端设备， 浏览器，协议，网络类型以及潜在的一些东西（CDNs， ISPs， 缓存， 代理，防火墙，负载均衡和服务器，它们都在性能问题上扮演非常重要的角色）。&lt;/p&gt;
&lt;p&gt;所以，如果我们实际环境中已经涉及到了上述的东西，那么从开始到网站最终的发布提升性能时这些的东西都应该考虑进去。这篇性能清单看上去如何？下面你将会得到一份（希望是公正的客观的）前端2017性能清单——上述问题你可能需要去考虑，以便确保网页响应时间够快，够流畅。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端, 性能" scheme="http://code.mrwaite.cn/tags/%E5%89%8D%E7%AB%AF-%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>纳新之后的一些收获</title>
    <link href="http://code.mrwaite.cn/2016/11/21/%E7%BA%B3%E6%96%B0%E4%B9%8B%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/"/>
    <id>http://code.mrwaite.cn/2016/11/21/纳新之后的一些收获/</id>
    <published>2016-11-21T13:47:28.000Z</published>
    <updated>2016-11-21T13:55:59.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经将近两个月没有更新博客的内容了.前面一个月是因为接到学校的宣传部网站的更新的任务(巨坑,对于自己的学习没有什么帮助,领导要求还多变,吐槽的就不多说了!),之后的一个月就是我所在的协会一年中最最重要的事,纳新.然后准备阶段前端组当然是最忙的了.我负责了纳新报名通道前后端,H5宣传页面,机考系统后端的开发.</p>
<p>下面是我在纳新当中自己总结的一些收获吧.</p>
<a id="more"></a>
<h2 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h2><ul>
<li>数据库的一些列的设置上,比如说男女,或者方向,可以就用<code>象征值</code>比如1 2 3等来表示.这样既可以节省存储的空间,而且就算是象征的含义改变了,代码方面改动很小.</li>
<li>nodejs安装npm依赖,还是<code>npm install</code>靠谱.<code>cnpm</code>因为更新时间等一些问题可能丢失一些依赖,导致nodejs进程崩溃.这个情况就在报名通道上线的时候发生过.</li>
<li>nodejs的请求处理方式和php相比有明显差别,nodejs<code>单线程</code>,php<code>多线程</code>.<a href="https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md" target="_blank" rel="external">Node.js的线程和进程</a>这篇文章让我明白了很多.</li>
<li>对于真实的场景,上线是一件很危险的事情,要做过完全的<code>测试</code>才能上线,就算你改了代码,用户浏览器端还是会有<code>缓存</code>.微信缓存强刷静态资源fingprint.</li>
<li>上线之前<code>gulp task</code>代码写好一点,小水管能压一点是一点,还有就是我开启了<code>gzip</code>对于一些静态资源的压缩很明显,大贺说划分主域对于小网站来说并没有这么明显,还有不要gzip png等图片文件.</li>
<li>使用<code>mysql</code>模块连接数据库的时候,要在每次操作完之后正确释放<code>connection</code>连接,不然就会产生很多<code>sleep</code>连接占用<code>mysql</code>,导致mysql不能正确对查询做出反应,使进程假死(就是进程没有崩,但是无法对请求做出响应)</li>
</ul>
<p>服务器端渲染 VS 客户端渲染</p>
<blockquote>
<p>完全使用浏览器端渲染。这样的缺点是：<br>网页加载速度慢，因为需要加载页面后再运行JavaScript，尤其是在移动设备上<br>无法做SEO，因为数据在JavaScript的数据结构中<br>使用服务器端渲染，可以避免上述的问题。</p>
<p>但是单纯的服务器端渲染也有问题，就是无法重新渲染。</p>
<p>解决的办法是，既使用服务器端渲染，也使用客户端渲染。让后端渲染一部分（比如首屏部分），后面的工作就交给前端异步去处理。两者结合起来效果才是最佳的。</p>
</blockquote>
<p>响应式方面:</p>
<blockquote>
<p>PC 端不做自适应了，都是 1060 吧<br>@content-width-small: 1060px;<br>@content-width-middle: 1060px;<br>@content-width-large: 1060px;</p>
<p>@phone: ~”only screen and (max-width: 767px)”;<br>@middle: ~”only screen and (min-width: 1140px) and (max-width: 1440px)”;<br>@large: ~”only screen and (min-width: 1440px)”;</p>
</blockquote>
<h2 id="非技术方面"><a href="#非技术方面" class="headerlink" title="非技术方面"></a>非技术方面</h2><ul>
<li>这次纳新准备阶段最失败的是任务的分配问题.按照大贺学长的话就是没有一个leader来指派任务,导致有些人的任务量很大完成情况不好,有些人手上没有分配到任务.</li>
<li>纵然之前做了很多准备,在宣讲会现场还是状况百出,这时候临场的指挥能力就显得尤为重要!</li>
<li>宣讲会现场,我的临场发挥还是紧张了!!尴尬..</li>
<li>最近的一个月也发生了好多事,大学在实验室待了一年多了,感觉有时候自己的社交圈太小了.和人交流的有点少.但是想想有收获就会有所牺牲吧.纳新也结束了,我们这帮大三离开实验室也要提上日程了,实验室确实给了我很多,所以也是心存感激.</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md" target="_blank" rel="external">Node.js的线程和进程</a><br><a href="http://blog.csdn.net/miltonzhong/article/details/9159481" target="_blank" rel="external"> mysql出现大量sleep进程的原因与解决方案</a><br><a href="https://segmentfault.com/a/1190000004259905" target="_blank" rel="external">记一次 MySQL 数据库问题排查</a><br><a href="http://www.cnblogs.com/rubylouvre/p/4128500.html" target="_blank" rel="external"> 转 谈谈前端渲染 VS 后端渲染</a><br><a href="http://yijiebuyi.com/blog/2ba090a3835d430726c922753b60b2ee.html" target="_blank" rel="external">node.js 和 nginx 配合实现 gzip 压缩,让网站浏览更顺畅</a><br><a href="http://blog.sina.com.cn/s/blog_68b56adb0100v9qt.html" target="_blank" rel="external">mysql插入数字都变成2147483647的解决方法 </a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;已经将近两个月没有更新博客的内容了.前面一个月是因为接到学校的宣传部网站的更新的任务(巨坑,对于自己的学习没有什么帮助,领导要求还多变,吐槽的就不多说了!),之后的一个月就是我所在的协会一年中最最重要的事,纳新.然后准备阶段前端组当然是最忙的了.我负责了纳新报名通道前后端,H5宣传页面,机考系统后端的开发.&lt;/p&gt;
&lt;p&gt;下面是我在纳新当中自己总结的一些收获吧.&lt;/p&gt;
    
    </summary>
    
    
      <category term="纳新" scheme="http://code.mrwaite.cn/tags/%E7%BA%B3%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>学习Gulp的一些收获</title>
    <link href="http://code.mrwaite.cn/2016/09/25/Gulp/"/>
    <id>http://code.mrwaite.cn/2016/09/25/Gulp/</id>
    <published>2016-09-25T12:29:49.000Z</published>
    <updated>2016-09-27T13:01:53.340Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><h2 id="ulp,Grunt,Webpack">Gulp,Grunt,Webpack</h2></div>

<p>之前一直对于<code>Grunt</code>,<code>Gulp</code>,<code>Webpack</code>它们之间到底是什么关系<br>一直迷惑不已,最近对于<code>Gulp</code>的学习中,算是对于它们有了初步的了解.   </p>
<p>其实<code>Grunt</code>和<code>Gulp</code>,与<code>webpack</code>不是一回事!</p>
<p><code>Gulp</code>应该和<code>Grunt</code>相互比较.它们都是一种工具能够优化前端的工作流程.像是<code>sass</code>的编译,自动添加css前缀,压缩css,js的校验合并压缩,监视功能.使用<code>Grunt</code>/<code>Gulp</code>,然后配置需要的插件,就可以让你脱离繁琐的手工操作,让这些自动化工具帮你完成.</p>
<a id="more"></a>
<p>而<code>webpack</code>是一种JS模块化的方案,和它功能类似有<code>browserify</code>,<code>seajs</code>,<code>requirejs</code>.虽然他们都是解决JS模块化的方案,但是他们之间还是有区别的.</p>
<ul>
<li><code>seajs</code>/<code>requirejs</code> : 是一种在线’编译’的的模块方案.怎么说就是,在页面上加载了AMD或者CMD解释器,然后浏览器可以通过这样的一个解释器,知道上面两个模块化规范的规则,就能认识<code>define</code>,<code>exports</code>,<code>module</code>等.</li>
<li><code>webpack</code>/<code>browserify</code> : 这是一个’预编译’模块的方案,它们不需要在浏览器当中加载,你只需要在本地写好符合模块化规范n的JS文件,然后通过相应的编译工具,就能编译成浏览器能识别的JS文件.</li>
</ul>
<p>当然<code>gulp</code>等自动化工具也能通过插件,使用像是<code>webpack</code>这样的模块化方案.</p>
<p>接下来主要讲讲我醉经了解的自动化工具<code>Gulp</code></p>
<div class="note info"><h2 id="预处理与后处理器">预处理与后处理器</h2></div>

<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>说到预处理器,<code>sass</code>,<code>less</code>,<code>stylus</code>都是目前比较主流的预处理器.用过像是<code>sass</code>这样的预处理器都知道,他们会有自己的一套语法,像是变量,函数,嵌套,混合器,继承等,然后再编译成浏览器能识别的css代码.这样,编译前和编译后是完全不同的语言</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ol>
<li>首次取到预处理器的源代码的分析树</li>
<li>将有动态生成的,比如一些变量和函数的分析树,转化成静态分析树</li>
<li>将静态分析树转化为<code>css</code>的分析树</li>
<li>将<code>css</code>分析树转化为css代码</li>
</ol>
<h3 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h3><p>而css后处理器是对css代码进行处理,最终生成的还是css代码,编译前的和编译后的代码都是css.</p>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><ol>
<li>先将源代码做css解析,获得分析树</li>
<li>对于得到的cs分析树,做后处理</li>
<li>将后处理好的css分析树,转换成css代码</li>
</ol>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>我感觉css预处理器可以算是一个新的语言新的语法,这样会增加我们的学习成本与使用门槛,而且可能会因为预处理器跟不上留恋器或者其他的版本的更迭而出现问题.而后处理器原先就是css语法,几乎是0门槛,它对于css分析树的处理是依据<code>can i use</code>网站实时的更新.但是css预处理器的强大之处在于逻辑能力的处理能力强,灵活,改善项目结构,而后处理器在这方便就显得拙荆见肘了.</p>
<h3 id="CSSGrace"><a href="#CSSGrace" class="headerlink" title="CSSGrace"></a>CSSGrace</h3><div class="note info"><h2 id="Gulp">Gulp</h2></div>

<p>看网上大家对于<code>Grunt</code>和<code>Gulp</code>的比较,好像<code>Gulp</code>比起<code>Grunt</code>配置更简单而且更容易阅读和维护,<code>Gulp</code>还支持管道处理!so,我就入坑<code>Gulp</code>.</p>
<p><code>Gulp</code>一般都是配合相应的插件来完成一些具体的任务的.</p>
<p><code>gulp.task</code>是用来创建任务的,<code>gulp-src</code>是设置需要处理的文件的路径(可以是多文件数组,也可以是正则表达式),<code>gulp-dest</code>是设置生成文件的路径(可以在一个插件结束之后立即保存,之后继续管道到下一个插件处理).</p>
<p>下面就列举一些常用的插件:</p>
<h4 id="gulp-ruby-sass-gulp-autoprefixer-gulp-minify-css"><a href="#gulp-ruby-sass-gulp-autoprefixer-gulp-minify-css" class="headerlink" title="gulp-ruby-sass + gulp-autoprefixer + gulp-minify-css"></a>gulp-ruby-sass + gulp-autoprefixer + gulp-minify-css</h4><p>上面这些插件的组合可以实现<code>sass</code>的编译,自动添加前缀,压缩.</p>
<h5 id="gulp-jshint-gulp-concat-gulp-uglify"><a href="#gulp-jshint-gulp-concat-gulp-uglify" class="headerlink" title="gulp-jshint + gulp-concat + gulp-uglify"></a>gulp-jshint + gulp-concat + gulp-uglify</h5><p>实现js代码的校验,合并和压缩,之前对于gulp-concat的合并有写疑惑?比如有些文件有依赖关系.查资料之后好像可以用webpack插件或者gulp-order来控制顺序之类的.</p>
<p>还有压缩图片,清除文件,这只默认任务,监听文件,自动刷新页面之类的插件的使用就不做累述了.</p>
<div class="note info"><h2 id="遇到的问题">遇到的问题</h2></div>

<p>之前参考一篇gulp的教程,上面gulp-sass插件是这么使用的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'src/styles/main.scss'</span>)</div><div class="line">    .pipe(sass(&#123; style: <span class="string">'expanded'</span> &#125;))</div><div class="line">    .pipe(autoprefixer(<span class="string">'last 2 version'</span>, <span class="string">'safari 5'</span>, <span class="string">'ie 8'</span>, <span class="string">'ie 9'</span>, <span class="string">'opera 12.1'</span>, <span class="string">'ios 6'</span>, <span class="string">'android 4'</span>))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/assets/css'</span>))</div><div class="line">    .pipe(rename(&#123;suffix: <span class="string">'.min'</span>&#125;))</div><div class="line">    .pipe(minifycss())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/assets/css'</span>))</div><div class="line">    .pipe(notify(&#123; message: <span class="string">'Styles task complete'</span> &#125;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>会报这样的错误:<code>Gulp.js TypeError: glob pattern string required</code></p>
<p>在stackoverflow上的解答之后才知道gulp-sass的API已经改变的了需要已这样的方式使用此插件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sass(<span class="string">'sass/*.scss'</span>, &#123;</div><div class="line">      style: <span class="string">'XXXXXXX'</span></div><div class="line">    &#125;)</div><div class="line">    .pipe(XXXXXX);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在使用gulp-jshint插件的时候遇到这样的报错:<code>Gulp Error: Cannot find module &#39;jshint/src/cli&#39;</code>,<br>原因是只是安装了gulp-jshint没有安装jshint,然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev jshint gulp-jshint</div></pre></td></tr></table></figure></p>
<div class="note info"><h2 id="最近的感想">最近的感想</h2></div>

<p>最近可能是感觉到了下一个寒假结束之后自己马上就要投投简历,找实习了.前几天又帮一个学长答笔试题:),看到现场来参加笔试的人是如此之多,竞争压力是如此之大(好像是几千人,就招三四十个人..)</p>
<p>也看到了一些同龄的也在学前端的在校大学生,感觉虽然自己学前端有段时间了,但是现在掌握的东西都是个p!!!!</p>
<p>就说最近看到的一个三本学校的大四学长的2015总结,上面提到的名词都有:Flex,react,Angular,sass,PHP,Redis,MongoDB,vue…</p>
<p>还是菜啊,加油吧,自己!</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;ulp,Grunt,Webpack&quot;&gt;Gulp,Grunt,Webpack&lt;/h2&gt;&lt;/div&gt;

&lt;p&gt;之前一直对于&lt;code&gt;Grunt&lt;/code&gt;,&lt;code&gt;Gulp&lt;/code&gt;,&lt;code&gt;Webpack&lt;/code&gt;它们之间到底是什么关系&lt;br&gt;一直迷惑不已,最近对于&lt;code&gt;Gulp&lt;/code&gt;的学习中,算是对于它们有了初步的了解.   &lt;/p&gt;
&lt;p&gt;其实&lt;code&gt;Grunt&lt;/code&gt;和&lt;code&gt;Gulp&lt;/code&gt;,与&lt;code&gt;webpack&lt;/code&gt;不是一回事!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gulp&lt;/code&gt;应该和&lt;code&gt;Grunt&lt;/code&gt;相互比较.它们都是一种工具能够优化前端的工作流程.像是&lt;code&gt;sass&lt;/code&gt;的编译,自动添加css前缀,压缩css,js的校验合并压缩,监视功能.使用&lt;code&gt;Grunt&lt;/code&gt;/&lt;code&gt;Gulp&lt;/code&gt;,然后配置需要的插件,就可以让你脱离繁琐的手工操作,让这些自动化工具帮你完成.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gulp" scheme="http://code.mrwaite.cn/tags/Gulp/"/>
    
  </entry>
  
  <entry>
    <title>Sass学习</title>
    <link href="http://code.mrwaite.cn/2016/08/13/Sass%E5%AD%A6%E4%B9%A0/"/>
    <id>http://code.mrwaite.cn/2016/08/13/Sass学习/</id>
    <published>2016-08-13T12:38:36.000Z</published>
    <updated>2016-08-13T13:14:30.263Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><h2 id="使用变量">使用变量</h2></div>

<blockquote>
<p><code>$</code>声明的变量是有块级作用域的</p>
<p><code>Sass</code>的变量名可以与css中的属性名和选择器名称相同</p>
<p>中划线或下划线这两种用法相互兼容</p>
</blockquote>
<div class="note info"><h2 id="嵌套css规则">嵌套css规则</h2></div>

<blockquote>
<p><code>Sass</code>会把父选择器放在子选择器前面，形成一条一条规则（但是这样的方案，根据css样式从右到左解析来说，效率不太好）</p>
<p><code>Sass</code>也有<code>@import</code>的功能，但是<code>Sass</code>是在<code>Sass</code>文件编译成<code>css</code>文件的时候就已经导入了，而且导入的文件是全局变量都可以使用</p>
<p>可以在选择器里面嵌套导入</p>
</blockquote>
<a id="more"></a>
<div class="note info"><h2 id="注释">注释</h2></div>

<blockquote>
<p>单行编译时注释会被忽略，多行不会。</p>
</blockquote>
<div class="note info"><h2 id="混合器">混合器</h2></div>

<blockquote>
<p>判断一组代码是否可以组成一个混合器，一条经验法则就是你能否为这个混合器相处一个好名字</p>
<p><code>css</code>类是对于<code>html</code>当中语义化的功能模块的描述，而混合器是对于<code>css</code>中最终呈现的样式效果的描述</p>
<p>混合器可以和函数一样传递参数，并且做一系列的分支循环判断</p>
</blockquote>
<p>混合器的实参的表示可以是这样的，不用考虑顺序的影响：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@mixin link-colors($normal, $hover, $visited) &#123;</div><div class="line">  color: $normal;</div><div class="line">  &amp;:hover &#123; color: $hover; &#125;</div><div class="line">  &amp;:visited &#123; color: $visited; &#125;</div><div class="line">&#125;</div><div class="line">a &#123;</div><div class="line">    @include link-colors(</div><div class="line">      $normal: blue,</div><div class="line">      $visited: green,</div><div class="line">      $hover: red</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 也可以这样展示默认的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@mixin link-colors(</div><div class="line">    $normal,</div><div class="line">    $hover: $normal,</div><div class="line">    $visited: $normal</div><div class="line">  )</div><div class="line">&#123;</div><div class="line">  color: $normal;</div><div class="line">  &amp;:hover &#123; color: $hover; &#125;</div><div class="line">  &amp;:visited &#123; color: $visited; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><div class="note info"><h2 id="继承">继承</h2></div><br>example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">.error &#123;</div><div class="line">  border : 1px red;</div><div class="line">  background : #fdd;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.error a &#123;</div><div class="line">  list-style-type: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line">h1.error &#123;</div><div class="line">  color : red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.seriousError &#123;</div><div class="line">  @extend .error;</div><div class="line">  border-width : 3px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">======&gt;</div><div class="line"></div><div class="line">.error, .seriousError &#123;</div><div class="line">  border: 1px red;</div><div class="line">  background: #fdd; &#125;</div><div class="line"></div><div class="line">.error a, .seriousError a &#123;</div><div class="line">  list-style-type: none; &#125;</div><div class="line"></div><div class="line">h1.error, h1.seriousError &#123;</div><div class="line">  color: red; &#125;</div><div class="line"></div><div class="line">.seriousError &#123;</div><div class="line">  border-width: 3px; &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>从上面就可以看出extand是怎么运行的，这时候就需要考虑如果前后样式冲突的时候怎么判断权重</p>
</blockquote>
<h3 id="继承的使用场景"><a href="#继承的使用场景" class="headerlink" title="继承的使用场景"></a>继承的使用场景</h3><p>你发现你的某个类（比如说.seriousError）另一个类（比如说.error）的细化。你会怎么做？</p>
<ol>
<li>可以为这两个类分别写相同的样式，但是如果有大量的重复怎么办？使用sass时提倡的就是不要做重复的工作。</li>
<li>可以使用一个选择器组（比如说.error.seriousError）给这两个选择器写相同的样式。如果.error的所有样式都在同一个地方，这种做法很好，但是如果是分散在样式表的不同地方呢？再这样做就困难多了。</li>
<li>你可以使用一个混合器为这两个类提供相同的样式，但当.error的样式修饰遍布样式表中各处时，这种做法面临着跟使用选择器组一样的问题。这两个类也不是恰好有相同的 样式。你应该更清晰地表达这种关系。</li>
<li>综上所述应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用.error``.seriousError都会继承其中的样式。</li>
</ol>
<h3 id="继承的工作细节"><a href="#继承的工作细节" class="headerlink" title="继承的工作细节"></a>继承的工作细节</h3><ol>
<li>继承重复的是选择器，但是混合器重复的是属性，继承的代码量更少一点</li>
<li>就是我上面说的继承之后可能要是会有冲突，看权重就好了</li>
</ol>
<h3 id="使用时注意的"><a href="#使用时注意的" class="headerlink" title="使用时注意的"></a>使用时注意的</h3><p>继承中不要使用后代选择器</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;使用变量&quot;&gt;使用变量&lt;/h2&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt;声明的变量是有块级作用域的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sass&lt;/code&gt;的变量名可以与css中的属性名和选择器名称相同&lt;/p&gt;
&lt;p&gt;中划线或下划线这两种用法相互兼容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;嵌套css规则&quot;&gt;嵌套css规则&lt;/h2&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Sass&lt;/code&gt;会把父选择器放在子选择器前面，形成一条一条规则（但是这样的方案，根据css样式从右到左解析来说，效率不太好）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sass&lt;/code&gt;也有&lt;code&gt;@import&lt;/code&gt;的功能，但是&lt;code&gt;Sass&lt;/code&gt;是在&lt;code&gt;Sass&lt;/code&gt;文件编译成&lt;code&gt;css&lt;/code&gt;文件的时候就已经导入了，而且导入的文件是全局变量都可以使用&lt;/p&gt;
&lt;p&gt;可以在选择器里面嵌套导入&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Sass" scheme="http://code.mrwaite.cn/tags/Sass/"/>
    
  </entry>
  
  <entry>
    <title>读JavaScript语言精粹收获</title>
    <link href="http://code.mrwaite.cn/2016/08/10/%E8%AF%BBJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E6%94%B6%E8%8E%B7/"/>
    <id>http://code.mrwaite.cn/2016/08/10/读JavaScript语言精粹收获/</id>
    <published>2016-08-10T09:43:09.000Z</published>
    <updated>2016-08-11T09:18:56.271Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><h2 id="前言">前言</h2></div>

<blockquote>
<p>接触<code>JavaScript</code>也有一段时间了，好早之前就在各方的<code>JavaScript</code>经典书籍推荐上纷纷提到过这本书。其实我也忘了是什么原因导致我好几次刚开始阅读这本书就中断了。这几天我就花了点时间仔细阅读了这本书。并写下这篇博客记录自己的收获，备忘。（按照本书的目录结构整理）  </p>
</blockquote>
<div class="note info"><h2 id="第一章：精华">第一章：精华</h2></div>

<blockquote>
<p>浏览器的<code>API</code>和文档对象模型<code>DOM</code>相当糟糕，它的规范制定的很拙劣并且实现互不一致。</p>
<p>那些优秀的想法包括：函数， 弱类型， 动态对象和富有表现力的对象字面量表示法。那些糟糕的想法包括给予全局变量的编程模型。</p>
<p>词法作用域是词法分析的过程中指派的作用域，在词法解析过程中定死。动态作用域在代码运行时定义，非代码解析时。动态不关心哪里声明，关心在哪里调用，和this相似，基于调用栈，词法作用域相反。</p>
<p><code>JavaScript</code>是一门弱类型语言。<code>JavaScript</code>有非常强大的对象字面量表示法。</p>
</blockquote>
<a id="more"></a>
<div class="note info"><h2 id="第二章：语法">第二章：语法</h2></div>

<blockquote>
<p>没有用的注释比没有注释更糟糕。/<em> </em>/注释可能会在正则表达式上出错。</p>
<p>在<code>JavaScript</code>保留字里面有一些本应该被保留而没有被保留的字，包括<code>undefined</code>，<code>NaN</code>和<code>Infinity</code>。</p>
<p><code>JavaScript</code>只有一种数字类型，它在内部被表示为64位浮点数。整数部分按照54位来算。        </p>
<p>只有下面被列出来的值被当做假（<code>false</code>）：<code>false</code>，<code>null</code>，<code>undefined</code>，空字符串 ‘ ‘，数字 0， 数字<code>NuN</code>。</p>
<p><code>typeof</code>运算一个数组或者<code>null</code>，那么结果是<code>&#39;object&#39;</code>。</p>
<p>定义字面量的时候，属性名可以是标识符或者字符串，对象的属性名是在编译的时候才能知道。</p>
</blockquote>
<div class="note info"><h2 id="第三章：对象">第三章：对象</h2></div>

<blockquote>
<p>数组是对象，函数是对象，正则表达式是对象，对象自然也是对象。属性名可以是包括空字符串在内的任意字符。<code>JavaScript</code>里面标识符包含连接符（-）是不合法的。</p>
<p>删除对象的属性可能会让来自原型链中的属性透现出来。（暴露出原型的接口）。</p>
</blockquote>
<div class="note info"><h2 id="第四章：函数">第四章：函数</h2></div>

<blockquote>
<p><code>JavaScript</code>设计最出色的地方就是它的函数实现。</p>
<p>函数的参数将被定义为函数中的变量。每个函数还会接受两个附加的参数：<code>this</code>和<code>arguments</code>。</p>
<p><code>this</code>有4种调用模式：1.方法调用 2.函数调用模式 3.构造器调用模式 4.<code>apply</code>调用模式</p>
<p>方法调用模式：<code>this</code>到对象绑定发生在调用的时候。这个‘超级’延迟绑定使得函数可以对<code>this</code>高度的复用。</p>
<p>函数调用模式：<code>this</code>绑定到全局对象，这是语言设计上的一个错误。<code>this</code>应该绑定到外部函数的<code>this</code>变量。</p>
<p><code>arguments</code>数组可以访问函数被调用的时候传递给的全部参数，包括那些没有分配给函数声明是定义的形式参数的多余参数。<code>arguments</code>是一个类数组对象。</p>
<p><code>JavaScript</code>没有提供尾递归优化。尾递归优化是函数返回自身地柜调用的结果，那个调用的过程会被替换成一个循环，显著提高速度。<code>JavaScript</code>深度递归可能会因为堆栈溢出而运行失败。</p>
</blockquote>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>(自己总结)闭包的应用场景：1.保护函数内变量安全：迭代器，生成器 2.在内存中维护变量：缓存数据， 柯理化。<code>this</code>指向上一个执行环境。</p>
<p>在闭包里面方法不是访问该参数的一个副本，它访问的是该参数本身。（执行环境未被销毁）</p>
</blockquote>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><blockquote>
<p>模块是一个提供接口却隐藏状态与实现的函数或者对象。（存在在执行环境中的私有变量）。</p>
<p>模块的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量的函数的特权函数；最后返回这个特权函数，或者把它们保存到一个可以访问的地方。</p>
</blockquote>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><blockquote>
<p>在方法的<code>return</code>处返回<code>this</code>而不是<code>undefined</code>。级联技术可以产出极富表现力的接口。</p>
<p>一个接口没有必要做太多的事。</p>
</blockquote>
<div class="note info"><h2 id="第五章：继承（没有看的很明白）">第五章：继承(没有看的很明白)</h2></div>

<h3 id="函数化"><a href="#函数化" class="headerlink" title="函数化"></a>函数化</h3><blockquote>
<p>继承模式的一个弱点就是没有办法保护隐私。我们有更好的选择就是应用模块模式。</p>
<p>该函数包括四个步骤：<br>1.创建一个新对象，有很对的方法可以构造一个对象。可以用对象字面量，或者<code>new</code>一个构造器函数，或者使用<code>Object.create</code>方法构造一个已存在函数的实例，或者调用任意一个会返回一个对象的函数。<br>2.有选择的定义私有实例变量和方法。<br>3.给新对象扩充方法。这些对象有特权取访问参数。<br>4.返回那个新对象。</p>
</blockquote>
<h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><blockquote>
<p>(里面有一个很好的例子)把一套部件组装出来。</p>
</blockquote>
<div class="note info"><h2 id="第六章：数组">第六章：数组</h2></div>

<blockquote>
<p><code>JavaScript</code>里的数组都是类数组对象。没有真正意义上的数组。</p>
<p><code>JavaScript</code>数组的<code>length</code>是没有上界的。如果你使用大于等于当前<code>length</code>的数字作为下标来存储一个元素，那么<code>length</code>会被增大，不会发生数组越界错误。</p>
<p>可以通过检查<code>constructor</code>属性判断是不是数组还是对象</p>
</blockquote>
<div class="note info"><h2 id="第九章：代码风格">第九章：代码风格</h2></div>

<blockquote>
<p><code>JavaScript</code>的弱类型和过度的容错性导致程序质量无法在编译的时候获得保障。</p>
<p>我对代码块内容和对象字面量缩进4个空格。我放了一个空格在<code>if</code>和<code>（</code>之间，让<code>if</code>看起来不想是函数调用。</p>
<p>我在除了<code>.</code>和<code>[</code>的所有的中置运算符的两边都放了空格。</p>
<p>把<code>{</code>放在一行的结尾而不是下一行的开始，因为它会避免<code>JavaScript</code>的<code>return</code>语句中一个可怕的设计错误。</p>
<p>在<code>JavaScript</code>中，我更喜欢使用行注释，我把快注释用于正式文档记录与注释。</p>
<p>在每个函数开始的部分声明我所有的变量。</p>
<p>不允许<code>switch</code>语句块中的条件穿越到下一个<code>case</code>语句。</p>
<p>使用闭包能提供进一步的信息隐藏，增强模块的健壮性。</p>
</blockquote>
<div class="note info"><h2 id="第十章：优美的特性">第十章：优美的特性</h2></div>

<h3 id="精简的JS都是好东西，包括"><a href="#精简的JS都是好东西，包括" class="headerlink" title="精简的JS都是好东西，包括"></a>精简的JS都是好东西，包括</h3><blockquote>
<p>1.函数是顶级对象。在精简的Js中，函数是有词法作用域的闭包<br>2.基于原型继承的动态对象。对象是无类别的。我们可以通过普通的赋值给任意对象增加一个新成员属性，一个对象可以从另一个对象继承成员属性。<br>3.对象字面量和数组字面量。这对创建新的对象和数组来说是一种非常方便的表示法。JS字面量是数据交换格式JSON的灵感之源。</p>
</blockquote>
<div class="note"><h2 id="后记">后记</h2></div>

<p>一本好书是，就算是只有薄薄的一百五十多页，但也是全程高能，根本停不下来啊。看完之后对于<code>JavaScript</code>这门语言有了更加全面的认识。任何一门被人们广泛使用语言都是有其过人之处，当然也有其糟粕，甚至是毒瘤。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;接触&lt;code&gt;JavaScript&lt;/code&gt;也有一段时间了，好早之前就在各方的&lt;code&gt;JavaScript&lt;/code&gt;经典书籍推荐上纷纷提到过这本书。其实我也忘了是什么原因导致我好几次刚开始阅读这本书就中断了。这几天我就花了点时间仔细阅读了这本书。并写下这篇博客记录自己的收获，备忘。（按照本书的目录结构整理）  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;h2 id=&quot;第一章：精华&quot;&gt;第一章：精华&lt;/h2&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;浏览器的&lt;code&gt;API&lt;/code&gt;和文档对象模型&lt;code&gt;DOM&lt;/code&gt;相当糟糕，它的规范制定的很拙劣并且实现互不一致。&lt;/p&gt;
&lt;p&gt;那些优秀的想法包括：函数， 弱类型， 动态对象和富有表现力的对象字面量表示法。那些糟糕的想法包括给予全局变量的编程模型。&lt;/p&gt;
&lt;p&gt;词法作用域是词法分析的过程中指派的作用域，在词法解析过程中定死。动态作用域在代码运行时定义，非代码解析时。动态不关心哪里声明，关心在哪里调用，和this相似，基于调用栈，词法作用域相反。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;是一门弱类型语言。&lt;code&gt;JavaScript&lt;/code&gt;有非常强大的对象字面量表示法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://code.mrwaite.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs单元测试</title>
    <link href="http://code.mrwaite.cn/2016/07/29/Nodejs%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://code.mrwaite.cn/2016/07/29/Nodejs单元测试/</id>
    <published>2016-07-29T09:30:08.000Z</published>
    <updated>2016-08-10T10:12:27.606Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><h2>使用模块</h2></div>

<h3 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a><a href="https://mochajs.org" target="_blank" rel="external">mocha</a></h3><p>@转载自阮一峰：<a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="external">测试框架Mocha实例教程</a><br>JavaScript测试框架之一，能在浏览器和Node环境使用。可以通过它为JavaScript应用添加测试，从而保证代码的质量。  </p>
<p>为了方便起见，在全句环境安装<code>mocha</code>：<code>npm install -g mocha</code></p>
<p>通常测试脚本与所要测试的源码脚本同名，但是后缀名为<code>.test.js</code>（表示测试）或者<code>.spex.js</code>（表示规格）。比如<code>add.jd</code>的测试脚本名称为<code>add.test.js</code>。   </p>
<p>在<code>mocha</code>语法里面：<br><code>describe</code>块称为“测试套件”，表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称，第二个参数是一个实际执行的函数。<br><code>it</code>块称为“测试用例”，表示一个单独的测试，为测试的最小单位。它是一个函数，第一个参数是测试用例的名称，第二个参数是一个实际执行的函数。  </p>
<p><code>describe</code>块孩提供了测试用例的四个hook： <code>before()</code>,<code>after()</code>,<code>beforeEach()</code>,<code>afterEach()</code>     </p>
<a id="more"></a>
<p><strong>注意</strong>：<br>在协作项目的时候应该考虑<code>mocha</code>的版本问题，因为在不同版本的<code>mocha</code>下是不兼容的。这时应该注意：  </p>
<ol>
<li><code>$ npm i mocha --save-dex</code>， 安装一个局部的<code>mocha</code>到项目目录中去</li>
<li><code>$ ./node_modules/.bin/mocha</code>， 用刚才安装的局部的<code>mocha</code>来跑测试代码<br>但是每次这样的输入很麻烦。可以通过使用<code>Makefile</code>帮助我们记住复杂的配置，详见：<a href="https://github.com/alsotang/node-lessons/blob/master/lesson6/README.md" target="_blank" rel="external">包教不包会</a>，<a href="http://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="external">Makefile详解</a>。</li>
</ol>
<h3 id="should"><a href="#should" class="headerlink" title="should"></a><a href="https://github.com/tj/should.js" target="_blank" rel="external">should</a></h3><p><code>should</code>是断言库模块之一，什么是“断言”？“断言”就是判断源码的实际执行结果与预期的执行结果是否一致，如果不一致就抛出错误。   </p>
<p>所有的测试用例（<code>it</code>块）都应该包含有一句或者多句断言。它是编写测试用例的关键。  </p>
<p><code>mocha</code>为了保持自己的灵活性，因此默认不提供断言的<code>API</code>。在Nodejs中mocha和should是协作完成的。</p>
<p>@转载自淘宝FED：<a href="https://github.com/tj/should.js" target="_blank" rel="external">断言库的比较</a><br>断言库 | 优点 | 缺点 | 备注<br>— | — | — | —<br>Nodejs核心库Assert | 无需第三方依赖 | 语法较烂 | -<br>Should.js | API比较语义 | 文档比较烂 | -<br>expect.js | - | - | 比较中庸<br>chai | 大而全的API | - | -</p>
<h3 id="istanbul"><a href="#istanbul" class="headerlink" title="istanbul"></a><a href="https://www.npmjs.com/package/istanbul" target="_blank" rel="external">istanbul</a></h3><p>Nodejs覆盖率统计工具。<br>作用：提供一系列指标取衡量单元测试覆盖了哪些功能代码。istanbul提供了代码的语句覆盖率，分支覆盖率，函数覆盖率和行覆盖率的统计。   </p>
<div class="note info"><h2>知识集成</h2></div>

<h3 id="单元测试类型"><a href="#单元测试类型" class="headerlink" title="单元测试类型"></a>单元测试类型</h3><ol>
<li>TDD（测试驱动开发）</li>
<li>BDD（行为驱动开发）</li>
</ol>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>@转载自阮一峰 ： <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">持续集成是上面？</a><br><strong>持续集成指的是 频繁的（一天多次）将代码集成到主干。 </strong><br>好处：  </p>
<ol>
<li>快速发现错误。每天完成一点更新，集成到主干，快速发现并定位错误。</li>
<li>防止分支大幅度偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成难度越来越大。<br><strong>持续集成的目的是为了让偿命快速迭代，同时还能保证高质量</strong>,核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败就不能集成。</li>
</ol>
<p>这里贴上蓬stephen蓬的评论：  </p>
<blockquote>
<p>阮老师讲的“持续集成”，正好是我在公司做了将近半年多互联网项目的一个工作流程。我们项目经历了两期，每期都要进行十几次迭代，每次迭代都会在上一个迭代的基&gt; 础上增加几个新功能，并且公司要求开发人员在编码前要先提交该功能的单体测试和集成测试的代码，然后才能开始写代码（所谓的测试驱动开发），然后测试人员要负&gt; 责写端到端的自动化测试代码。公司用Jenkins进行持续集成，SVN管理代码库，Git进行团队开发，Sonar进行代码质量检查。项目成员每天早晨都会收到Jenkins服务&gt; 器发来的前一天的集成测试报告，通知前一天的提交是否完全通过。经历了这样一个持续迭代的过程，给客户交付的代码质量有保证，很少或几乎没有出现过回滚的情况。</p>
</blockquote>
<h3 id="npm-使用积累"><a href="#npm-使用积累" class="headerlink" title="npm 使用积累"></a>npm 使用积累</h3><p><code>npm</code>的<code>package.json</code>提供了三种依赖关系的定义：   </p>
<ol>
<li>dependencies</li>
<li>peerDependencies</li>
<li>devDependencies<br>其中<code>devDependencies</code>是开发是依赖的，比如模块用<code>mocha</code>来测试框架，那么模块开发就依赖<code>mocha</code>,如果别人想为你的模块贡献代码，他也需要安装<code>mocha</code>。但是只是用你模块的人就没必要安装<code>mocha</code>。<br><code>perrDependencies</code>是为插件准备的。比如<code>grunt</code>的插件，里面没有<code>require(&#39;grunt&#39;)</code>，所以用dependencies就有问题。所以需要单独列出来。</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Ubuntu下用命令行快速打开各种类型的文件：<code>xdg-open &lt;filename&gt;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;h2&gt;使用模块&lt;/h2&gt;&lt;/div&gt;

&lt;h3 id=&quot;mocha&quot;&gt;&lt;a href=&quot;#mocha&quot; class=&quot;headerlink&quot; title=&quot;mocha&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://mochajs.org&quot;&gt;mocha&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;@转载自阮一峰：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html&quot;&gt;测试框架Mocha实例教程&lt;/a&gt;&lt;br&gt;JavaScript测试框架之一，能在浏览器和Node环境使用。可以通过它为JavaScript应用添加测试，从而保证代码的质量。  &lt;/p&gt;
&lt;p&gt;为了方便起见，在全句环境安装&lt;code&gt;mocha&lt;/code&gt;：&lt;code&gt;npm install -g mocha&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通常测试脚本与所要测试的源码脚本同名，但是后缀名为&lt;code&gt;.test.js&lt;/code&gt;（表示测试）或者&lt;code&gt;.spex.js&lt;/code&gt;（表示规格）。比如&lt;code&gt;add.jd&lt;/code&gt;的测试脚本名称为&lt;code&gt;add.test.js&lt;/code&gt;。   &lt;/p&gt;
&lt;p&gt;在&lt;code&gt;mocha&lt;/code&gt;语法里面：&lt;br&gt;&lt;code&gt;describe&lt;/code&gt;块称为“测试套件”，表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称，第二个参数是一个实际执行的函数。&lt;br&gt;&lt;code&gt;it&lt;/code&gt;块称为“测试用例”，表示一个单独的测试，为测试的最小单位。它是一个函数，第一个参数是测试用例的名称，第二个参数是一个实际执行的函数。  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;describe&lt;/code&gt;块孩提供了测试用例的四个hook： &lt;code&gt;before()&lt;/code&gt;,&lt;code&gt;after()&lt;/code&gt;,&lt;code&gt;beforeEach()&lt;/code&gt;,&lt;code&gt;afterEach()&lt;/code&gt;     &lt;/p&gt;
    
    </summary>
    
    
      <category term="Nodejs" scheme="http://code.mrwaite.cn/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>nodejs爬虫编写时的一些收获</title>
    <link href="http://code.mrwaite.cn/2016/07/28/nodejs%E7%88%AC%E8%99%AB%E7%BC%96%E5%86%99%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/"/>
    <id>http://code.mrwaite.cn/2016/07/28/nodejs爬虫编写时的一些收获/</id>
    <published>2016-07-28T01:20:45.000Z</published>
    <updated>2016-08-11T09:14:09.103Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">使用的模块</div>

<h3 id="superagent"><a href="#superagent" class="headerlink" title="superagent"></a><a href="https://github.com/visionmedia/superagent" target="_blank" rel="external">superagent</a></h3><p><code>superagent</code>是nodejs里一个非常方便的客户端请求代理模块。感觉是封装了<code>http</code>内置模块的一些功能，比如<code>http</code>模块里面会有这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http.get(<span class="string">'http://cnodejs.org/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">	res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;&#125;);</div><div class="line">	res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>然后相应的<code>superagent</code>代码结构类似的就可以是这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">superagent.get(<span class="string">'http://cnodejs.org'</span>).end(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>有所类似，并没有研究过<code>superagent</code>源码。。   </p>
<p>当然<code>superagnet</code>还有一些其他强大的功能：</p>
<ol>
<li>完美的链式写法</li>
<li>设置请求头部</li>
<li>支持全部的http请求方式，并提供相应的参数设置</li>
<li>可以帮你解析返回的数据，支持三种类型的数据 ：<code>application/x-www-form-urlencoded</code> <code>application/json</code> 和<code>multipart/form-data</code></li>
<li>支持通过<code>pipe</code>管道流入流出数据<br>还有其他</li>
</ol>
<a id="more"></a>
<h3 id="cheerio"><a href="#cheerio" class="headerlink" title="cheerio"></a><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="external">cheerio</a></h3><p>为服务器特别定制的，快速，灵活，实时的<code>jQuery</code>核心实现  </p>
<blockquote>
<p>Cheerio实现了jQuery核心的一个子集。Cheerio 从jQuery库中删除了所有的DOM不一致和浏览器兼容支持，呈现其真正华丽的API。<br>Cheerio 使用一个非常简单的，一致的DOM模型。这样解析，操作和呈现就会带来令人难以置信的性能提升。初步的端至端的基准测试表明Cheerio比JSDOM快大概8倍。<br>兼容htmlparser2API。Cheerio可以解析几乎所有的HTML或XML文档。</p>
</blockquote>
<p>官网上的例子就已经很易懂了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>),</div><div class="line">$ = cheerio.load(<span class="string">''</span>); <span class="comment">//or $ = cheerio.load('爬虫爬取的网页');</span></div><div class="line">ex : $(<span class="string">'#fruits'</span>)</div></pre></td></tr></table></figure></p>
<p>这样就可以解析爬取的网页的信息<br>然后在用<code>cheerio</code>的过程中遇到了<code>$(&#39;.example:eq(0)&#39;)</code>报错的问题，经过几番摸索才知道<code>cheerio</code>是不支持<code>:eq</code>但是支持$().eq()。<br>要是想使用<code>$(&#39;.example:eq(0)&#39;)</code>，那就需要<a href="https://github.com/watson/cheerio-eq" target="_blank" rel="external">cheerio-eq</a>这个模块。</p>
<h3 id="async-与-EventProxy"><a href="#async-与-EventProxy" class="headerlink" title="async 与 EventProxy"></a><a href="https://github.com/caolan/async" target="_blank" rel="external">async</a> 与 <a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">EventProxy</a></h3><p>关于上面这两个模块的信息，我想网上已经很多了，我就不做累述。简单的说就是都是做异步流程控制的。   </p>
<p>那什么时候用<code>eventproxy</code> ,什么时候用<code>async</code>?<br><figure class="highlight plain"><figcaption><span>@alsotang</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当你需要去多个源(一般是小于 10 个)汇总数据的时候，用 eventproxy 方便；当你需要用到队列，需要控制并发数，或者你喜欢函数式编程思维时，使用 async。</div></pre></td></tr></table></figure></p>
<p>应该是各有各的优势，但是现在我感觉<code>async</code>的控制并发连接数，对于爬虫来说实在是好用。  </p>
<div class="note warning">调试之中遇到的问题</div>

<h3 id="回调函数是可以取到上一级作用域的变量的"><a href="#回调函数是可以取到上一级作用域的变量的" class="headerlink" title="回调函数是可以取到上一级作用域的变量的"></a>回调函数是可以取到上一级作用域的变量的</h3><p>原先以为在运行到回调函数的时候，会找不到原先的作用域，看来是想多了。</p>
<h3 id="async-mapLimit与superagnet并用"><a href="#async-mapLimit与superagnet并用" class="headerlink" title="async.mapLimit与superagnet并用"></a>async.mapLimit与superagnet并用</h3><p>问题： 设置并发数为5，然后只执行了5个请求就停止请求了。<br>解决： 在<code>superagnet.end()</code>回调函数里加上<code>callback(null, example)</code>。</p>
<h3 id="503-Service-Temporarily-Unavailable"><a href="#503-Service-Temporarily-Unavailable" class="headerlink" title="503 Service Temporarily Unavailable"></a>503 Service Temporarily Unavailable</h3><p><strong>状态码503</strong>：<br><figure class="highlight plain"><figcaption><span>@百度百科 </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">503 Service Unavailable：由于临时的服务器维护或者过载，服务器当前无法处理请求。注意：503状态码的存在并不意味着必须在服务器过载的时候使用它。某些服务器只不过是希望拒绝某些客户端的连接。</div></pre></td></tr></table></figure></p>
<p>这个问题是在爬虫去爬取网页的时候出现的，我原先是想并发40个请求取爬取网站上的信息。但是每次都是爬取到11～12的时候就停止爬取了。（原谅我的无知）<br>首先排查代码的正确性之后，想到的第一个可能性是因为用的是HTTP/1.1的并发限制<code>？</code>，然后经过一番查阅，才知道所谓的并发限制只是浏览器出于对于服务器保护的自发的自我限制。现在的浏览器虽然加大了并发请求书的限制，但是仍然控制在8以内。但是我的爬虫并不是经过浏览器发起请求的，所以并不是上面的问题。<br>第二种可能性，既然不是请求方的问题，那可能是接收端的问题。果然是服务器的问题（其实是我的问题）。   </p>
<p>转载：<a href="http://developer.51cto.com/art/200908/144792.htm" target="_blank" rel="external">服务器反爬虫策略</a><br>上面这篇文章说了服务器是如何防御爬虫的，我总结一下一共有以下几点：</p>
<ol>
<li>手工识别和拒绝爬虫的访问</li>
<li>通过识别爬虫的User-Agent信息来拒绝爬虫</li>
<li>通过网站流量统计系统和日志分析来识别爬虫</li>
<li>网站的实时反爬虫防火墙实现策略</li>
<li>用网站流量统计系统来改进实时反爬虫系统</li>
<li>用时间窗口来改进实时反爬虫系统</li>
</ol>
<p>之后才知道除去 CNode 的话，别的网站有可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的 IP 封掉。还是年轻啊！</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;使用的模块&lt;/div&gt;

&lt;h3 id=&quot;superagent&quot;&gt;&lt;a href=&quot;#superagent&quot; class=&quot;headerlink&quot; title=&quot;superagent&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/visionmedia/superagent&quot;&gt;superagent&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;superagent&lt;/code&gt;是nodejs里一个非常方便的客户端请求代理模块。感觉是封装了&lt;code&gt;http&lt;/code&gt;内置模块的一些功能，比如&lt;code&gt;http&lt;/code&gt;模块里面会有这样的代码：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;http.get(&lt;span class=&quot;string&quot;&gt;&#39;http://cnodejs.org/&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;res&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	res.on(&lt;span class=&quot;string&quot;&gt;&#39;data&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;chunk&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	res.on(&lt;span class=&quot;string&quot;&gt;&#39;end&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;).on(&lt;span class=&quot;string&quot;&gt;&#39;error&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后相应的&lt;code&gt;superagent&lt;/code&gt;代码结构类似的就可以是这样：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;superagent.get(&lt;span class=&quot;string&quot;&gt;&#39;http://cnodejs.org&#39;&lt;/span&gt;).end(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有所类似，并没有研究过&lt;code&gt;superagent&lt;/code&gt;源码。。   &lt;/p&gt;
&lt;p&gt;当然&lt;code&gt;superagnet&lt;/code&gt;还有一些其他强大的功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完美的链式写法&lt;/li&gt;
&lt;li&gt;设置请求头部&lt;/li&gt;
&lt;li&gt;支持全部的http请求方式，并提供相应的参数设置&lt;/li&gt;
&lt;li&gt;可以帮你解析返回的数据，支持三种类型的数据 ：&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; &lt;code&gt;application/json&lt;/code&gt; 和&lt;code&gt;multipart/form-data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;支持通过&lt;code&gt;pipe&lt;/code&gt;管道流入流出数据&lt;br&gt;还有其他&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://code.mrwaite.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs:module.exports 与 exports的区别</title>
    <link href="http://code.mrwaite.cn/2016/07/21/Nodejs-module-exports-%E4%B8%8E-exports%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://code.mrwaite.cn/2016/07/21/Nodejs-module-exports-与-exports的区别/</id>
    <published>2016-07-21T12:58:29.000Z</published>
    <updated>2016-07-30T04:44:51.715Z</updated>
    
    <content type="html"><![CDATA[<p>在讲Nodejs中module.exports 与 exports 的区别之前，我想先说说Nodejs的模块是如何加载的。<br></p>
<p>首先，如果你使用 <code>nodejs xxx.js</code> 运行js文件的时候看过用调试工具（ex: <code>node-supervisor</code> ）查看过node<strong>编译</strong>之后的文件，你会发现在最上方<code>require</code>加载模块的地方，会出现这样的匿名函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><br></p>
<p>这是Nodejs在编译js文件的过程中有对js文件的头部包装。之后会传入 <code>module.exports</code> , <code>require</code> 方法， <code>module</code> , 文件名，目录名作为参数并执行。<br><br><br>这个时候我就想到了，在express的app.js中时常会出现这样的 <code>path.join(__dirname, &#39;views&#39;）</code>，设置 <code>__dirname</code> 的语句。还有就是为什么js文件里面没有定义require函数，但是可以调用的原因。<br><strong>那在函数里面到底是怎么执行的，才会出现这样的匿名函数？</strong>   </p>
<ol>
<li>Nodejs通过 <code>startup</code> 方法初始化</li>
<li>进入 <code>Module.runMain</code> 方法</li>
<li><code>runMain</code> 方法中，执行 <code>Module.__load</code> (参数里面指向所需加载的js文件)</li>
<li>在 <code>__load</code> 方法里面会执行 <code>Module.__extensions[extension](this, filename)</code> ,来根据文件名的后缀调用具体的解析方式</li>
<li>在 <code>__extensions</code> 方法里面会读取js文件的内容并通过<code>Module.__compile</code>方法编译</li>
<li><strong>重点</strong>在 <code>__compile</code> 方法里面会执行： <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dirname = path.dirname(filename);</div><div class="line"> 	<span class="keyword">const</span> <span class="built_in">require</span> = internalModule.makeRequireFunction.call(<span class="keyword">this</span>);</div><div class="line"> 	<span class="keyword">const</span> args = [<span class="keyword">this</span>.exports, <span class="built_in">require</span>, <span class="keyword">this</span>.filename, dirname];</div><div class="line"> 	<span class="keyword">return</span> compiledWrapper.apply(<span class="keyword">this</span>.exports, args);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>所以会读取 <code>dirname</code>，<code>require</code>，并把this.exports等一系列变量作为参数返回。   </p>
<h2 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h2><p>在上面我们可以很明确的看到module.exports会作为匿名函数的参数，事实上requir()返回的是 <code>module.exports</code> 而不是 <code>exports</code>, 而且 <code>exports</code> 只是指向 <code>module.exports</code> 的引用。  </p>
<p>所以：</p>
<h3 id="我们这样写是可行的："><a href="#我们这样写是可行的：" class="headerlink" title="我们这样写是可行的："></a>我们这样写是可行的：</h3><p><strong>exports:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.area = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><strong>module.exports:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="但是这样写是不行的"><a href="#但是这样写是不行的" class="headerlink" title="但是这样写是不行的"></a>但是这样写是不行的</h3><p><strong>exports:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>因为<code>exports</code> 只是指向 <code>module.exports</code> 的引用,就是 <code>exports</code> 和 <code>module.exports</code> 指向的是同一块内存。上面的第一个例子，只是对于 <code>exports</code> 指向的内存上面的area方法做了修改，指向关系没有变化。上面第二个例子是对 <code>exports</code> 的指向关系做了修改，指向了一块新的内存。那么， <code>exports</code> 和 <code>module.exports</code> 两者的关系就被切断了。 那么因为 <code>require()</code> 取的还是 <code>module.exports</code> ，所以按照第二个例子定义模块向外暴露的接口就有问题。</p>
<h3 id="如果你还是对exports有种“畸形”的热爱：）"><a href="#如果你还是对exports有种“畸形”的热爱：）" class="headerlink" title="如果你还是对exports有种“畸形”的热爱：）"></a>如果你还是对exports有种“畸形”的热爱：）</h3><p>那么可以用下面这种<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exports = <span class="built_in">module</span>.exports = somethings；</div></pre></td></tr></table></figure></p>
<p><strong>槽点</strong>：既然都这么写了，用 <code>exports</code> 不就是多此一举吗！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讲Nodejs中module.exports 与 exports 的区别之前，我想先说说Nodejs的模块是如何加载的。&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;首先，如果你使用 &lt;code&gt;nodejs xxx.js&lt;/code&gt; 运行js文件的时候看过用调试工具（ex: &lt;code&gt;node-supervisor&lt;/code&gt; ）查看过node&lt;strong&gt;编译&lt;/strong&gt;之后的文件，你会发现在最上方&lt;code&gt;require&lt;/code&gt;加载模块的地方，会出现这样的匿名函数：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;exports, require, module, __filename, __dirname&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; cheerio = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;cheerio&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Nodejs" scheme="http://code.mrwaite.cn/tags/Nodejs/"/>
    
  </entry>
  
</feed>
